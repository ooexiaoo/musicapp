/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer";
exports.ids = ["vendor-chunks/nodemailer"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer/lib/mail.js":
/*!*********************************************!*\
  !*** ./node_modules/nodemailer/lib/mail.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var SMTPClient = exports.SMTPClient = __webpack_require__(/*! ./smtp */ \"(rsc)/./node_modules/nodemailer/lib/smtp.js\").SMTPClient,\n    mimelib = __webpack_require__(/*! mimelib-noiconv */ \"(rsc)/./node_modules/mimelib-noiconv/index.js\"),\n    exec = (__webpack_require__(/*! child_process */ \"child_process\").exec)\n    util = __webpack_require__(/*! util */ \"util\"),\n    EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n/*\n * Version constants\n */\nvar X_MAILER_NAME = \"Nodemailer\",\n    X_MAILER_VERSION = \"0.1.20; +http://www.nodemailer.org\";\n\n/**\n * mail\n * \n * Provides an API to send e-mails with Node.js through a SMTP server.\n * This API is unicode friendly, you don't have to escape non-ascii chars.\n * \n * NB! Before sending any e-mails, update mail.SMTP with correct values\n * \n **/\n\n\n// EXPOSE TO THE WORLD\n\n/**\n * mail.SMTP -> Object\n * \n * Configuration object, keeps the needed values to connect to the SMTP server\n * \n *   - **host** Hostname of the SMTP server (required)\n *   - **port** SMTP server port, defaults to 25\n *   - **hostname** hostname of the local server, needed for identifying,\n *     defaults to *untitled.server*\n *   - **use_authentication** if set to *true* authentication procedure is\n *     run after a successful connection\n *   - **user** username for authentication\n *   - **pass** password for authentication\n **/\nexports.SMTP = {\n    host: false,\n    port: false,\n    hostname: false,\n    use_authentication: false,\n    ssl: false,\n    user: false,\n    pass: false\n};\n\nexports.CommonServers = {\n    gmail:[],\n    yahoo:[],\n    hotmail:[]\n};\n\n/**\n * mail.sendmail -> Boolean | String\n * \n * If set to true, \"sendmail\" command will be used instead of SMTP\n * If the value is a String then it will be used as the sendmail command\n * \n *     mail.sendmail = true\n * \n * or\n * \n *     mail.sendmail = \"/path/to/sendmail\"\n **/\nexports.sendmail = false;\n\n// Expose EmailMessage for the world\nexports.EmailMessage = EmailMessage;\n\n/**\n * mail.send_mail(params, callback) -> undefined\n * - params (Object): e-mail data\n * - callback (Function): will be run after completion\n * \n * Shortcut function to send e-mails. See EmailMessage for param structure\n **/\nexports.send_mail = function(params, callback){\n    var em = new EmailMessage(params);\n    em.send(callback);\n    return em;\n};\n\nvar gencounter = 0,\n    instancecounter = 0;\n\n/**\n * new mail.EmailMessage(params)\n * - params (Object): message data (can be altered afterwards)\n * \n * Creates an object to send an e-mail.\n * \n * params can hold the following data\n *\n *   - **server** server to send message to (will default to exports.SMTP)\n *   - **sender** e-mail address of the sender\n *   - **headers** an object with custom headers.\n *     `{\"X-Myparam\": \"test\", \"Message-ID\":\"12345\"}`\n *   - **to** comma separated list of TO: addressees\n *   - **cc** comma separated list of CC: addressees\n *   - **bcc** comma separated list of BCC: addressees\n *   - **reply_to** A reply-to address\n *   - **subject** Message subject\n *   - **body** Message body in plain text\n *   - **html** Message body in HTML format\n *   - **attachments** an array of attachements of {filename, contents, cid}\n *     filename (mandatory) is a String, contents can be String or Buffer,\n *     cid is optional.\n * \n *   - **debug** if set, outputs the whole communication of SMTP server to console\n * \n * All the params can be edited/added after defining the object\n *\n * Events:\n *     forward(oldAddr,newAddr) - was told to try new address by server.\n *     defer(addr) - server takes responsibility for delivery.\n *     retain(addr) - unable to send to mailbox.\n * Usage:\n *     var em = EmailMessage();\n *     em.sender = '\"Andris Reinman\" <andris@node.ee>'\n *     em.to = 'andris@kreata.ee'\n *     em.body = \"Hello world!\";\n *     em.send(function(error, success){});\n *     \n *  NB! mail.SMTP needs to be set before sending any e-mails!\n **/\nfunction EmailMessage(params){\n    EventEmitter.call(this);\n    params = params || {};\n    this.SERVER = params.server || exports.SMTP;\n    this.sender = params.sender;\n    this.headers = params.headers || {};\n    this.to = params.to;\n    this.cc = params.cc;\n    this.bcc = params.bcc;\n    this.reply_to = params.reply_to;\n    this.subject = params.subject || \"\";\n    this.body = params.body || \"\";\n    this.html = params.html;\n    this.attachments = params.attachments || [];\n    \n    this.debug = !!params.debug;\n    \n    this.charset = params.charset || \"UTF-8\";\n    this.encoding = params.encoding || \"quoted-printable\";\n    \n    this.callback = null;\n}\nvar utillib = __webpack_require__(/*! util */ \"util\");\nutil.inherits(EmailMessage,EventEmitter);\n\n/**\n * mail.EmailMessage#prepareVariables() -> undefined\n * \n * Prepares some needed variables\n **/\nEmailMessage.prototype.prepareVariables = function(){\n    if(this.html || this.attachments.length){\n        this.content_multipart = true;\n        this.content_mixed = !!this.attachments.length;\n    //'=_' is not valid quoted printable\n    //'?' is not in any known base64 extension\n        this.content_boundary = \"----NODEMAILER-?=_\"+(++gencounter)+\"-\"+Date.now();\n        \n        // defaults to multipart/mixed but if there's attachments with cid value set\n        // use multipart/related - mail clients hide the duplicates this way\n        var mixed = \"mixed\";\n        for(var i=0, len=this.attachments.length; i<len;i++){\n            if(this.attachments[i].cid){\n                mixed = \"related\";\n                break;\n            }\n        }\n        this.content_type = \"multipart/\"+(this.content_mixed?mixed:\"alternative\")+\n                \"; boundary=\\\"\"+this.content_boundary+\"\\\"\";\n    }else{\n        this.content_multipart = false;\n        this.content_type = \"text/plain; charset=\"+this.charset;\n        this.content_transfer_encoding = this.encoding;  // Changed from quoted-printable; 5/23/2011.\n    }\n}\n\n/**\n * mail.EmailMessage#generateHeaders() -> String\n * \n * Generates a header string where lines are separated by \\r\\n\n **/\nEmailMessage.prototype.generateHeaders = function(){\n    \n    var headers = [];\n    \n    // Mime\n    headers.push([\n        \"X-Mailer\",\n        X_MAILER_NAME+\" (\"+X_MAILER_VERSION+\")\"\n    ].join(\": \"));\n    \n    // add custom\n    var keys = Object.keys(this.headers);\n    for(var i=0, len=keys.length; i<len; i++){\n        headers.push([\n            upperFirst(keys[i].trim()),\n            this.headers[keys[i]]\n        ].join(\": \"));\n    }\n    \n    // Date\n    var date = new Date;\n    headers.push([\n        upperFirst(\"Date\"),\n        date.toGMTString()\n    ].join(\": \"));\n\n    // From\n    var from = this.generateAddresses(this.sender,1, \"fromAddress\");\n    if(from.length){\n        headers.push([\n            upperFirst(\"From\"),\n            from\n        ].join(\": \"));    \n    }\n    \n    // To\n    var to = this.generateAddresses(this.to, 0, \"toAddress\");\n    if(to.length){\n        headers.push([\n            upperFirst(\"To\"),\n            to\n        ].join(\": \"));    \n    }\n    \n    // CC\n    var cc = this.generateAddresses(this.cc, 0, \"toAddress\");\n    if(cc.length){\n        headers.push([\n            upperFirst(\"Cc\"),\n            cc\n        ].join(\": \"));    \n    }\n    \n    // BCC\n    var bcc = this.generateAddresses(this.bcc, 0, \"toAddress\");\n    if(exports.sendmail && bcc.length){\n        headers.push([\n            upperFirst(\"Bcc\"),\n            bcc\n        ].join(\": \"));\n    }\n\n    //Reply-To\n    var reply_to = this.generateAddresses(this.reply_to, 1);\n    if(reply_to.length){\n        headers.push([\n            upperFirst(\"Reply-To\"),\n            reply_to\n        ].join(\": \"));\n    }\n    \n    // Subject\n    headers.push([\n        upperFirst(\"Subject\"),\n        this.subject && (hasUTFChars(this.subject) && \n              mimelib.encodeMimeWord(this.subject, \"Q\") || this.subject) || ''\n    ].join(\": \"));\n\n    // Mime\n    headers.push([\n        \"MIME-Version\",\n        \"1.0\"\n    ].join(\": \")); \n    \n    // Content-type\n    headers.push([\n        \"Content-Type\",\n        this.content_type\n    ].join(\": \")); \n    \n    if(!this.content_multipart){\n        headers.push([\n            \"Content-Transfer-Encoding\",\n            this.content_transfer_encoding\n        ].join(\": \"));\n    }\n    \n    // output\n    return headers.map(function(elm){\n        return mimelib.foldLine(elm);\n    }).join(\"\\r\\n\");\n}\n\n/**\n * mail.EmailMessage#generateBody() -> String\n * \n * Generates a body string. If this is a multipart message then different\n * parts will be separated by boundary, body+html are put into separate\n * multipart/alternate block\n **/\nEmailMessage.prototype.generateBody = function(){\n\n    if(!this.content_multipart){\n        return this.body && mimelib.encodeQuotedPrintable(this.body) || \"\";\n    }\n    \n    var body_boundary = this.content_mixed?\n            \"----NODEMAILER-?=_\"+(++gencounter)+\"-\"+Date.now():\n            this.content_boundary,\n        rows = [];\n    \n\n    if(this.content_mixed){\n        rows.push(\"--\"+this.content_boundary);\n        rows.push(\"Content-Type: multipart/alternative; boundary=\\\"\"+body_boundary+\"\\\"\");\n        rows.push(\"\");\n    }\n    \n    if(!this.body.trim() && this.html){\n        this.body = stripHTML(this.html);\n    }\n    \n    // body\n    rows.push(\"--\"+body_boundary);\n    rows.push(\"Content-Type: text/plain; charset=\"+this.charset);\n    rows.push(\"Content-Transfer-Encoding: \"+this.encoding); // Changed from quoted-printable; 5/23/2011.\n    rows.push(\"\");\n    // dots in the beginning of the lines will be replaced with double dots\n    rows.push(mimelib.encodeQuotedPrintable(this.body.trim()).replace(/^\\./gm,'..'));\n    rows.push(\"\");\n    \n    // html\n    if(this.html){\n        rows.push(\"--\"+body_boundary);\n        rows.push(\"Content-Type: text/html; charset=\"+this.charset);\n        rows.push(\"Content-Transfer-Encoding: \"+this.encoding); // Changed from quoted-printable; 5/23/2011.\n        rows.push(\"\");\n        rows.push(mimelib.encodeQuotedPrintable(this.html.trim()).replace(/^\\./gm,'..'));\n        rows.push(\"\");\n    }\n    \n    if(this.content_mixed){\n        rows.push(\"--\"+body_boundary+\"--\");\n    }\n    \n    // attachments\n    var current;\n    for(var i=0; i<this.attachments.length; i++){\n\n        current = {\n            filename: hasUTFChars(this.attachments[i].filename)?\n                    mimelib.encodeMimeWord(this.attachments[i].filename, \"Q\"):\n                    this.attachments[i].filename.replace(/\"/g,''),\n            mime_type: getMimeType(this.attachments[i].filename),\n            contents: this.attachments[i].contents instanceof Buffer?\n                    this.attachments[i].contents:\n                    new Buffer(this.attachments[i].contents, \"utf-8\"),\n            disposition: \"attachment\",\n            content_id: this.attachments[i].cid || ((++gencounter)+\".\"+Date.now()+\"@\"+(this.SERVER.hostname || \"localhost\"))\n        };\n        \n        \n        rows.push(\"--\"+this.content_boundary);\n        \n        rows.push(\"Content-Type: \"+current.mime_type+\"; name=\\\"\"+current.filename+\"\\\"\");\n        rows.push(\"Content-Disposition: \"+current.disposition+\"; filename=\\\"\"+current.filename+\"\\\"\");\n        rows.push(\"Content-ID: <\"+current.content_id+\">\");\n        \n        rows.push(\"Content-Transfer-Encoding: base64\");\n        rows.push(\"\");\n        \n        /* Changed to conform with RFC-2045 section 6.7. */\n        rows.push(current.contents.toString(\"base64\").replace(/.{76}/g,\"$&\\r\\n\"));\n        \n    }\n    \n    \n    rows.push(\"--\"+this.content_boundary+\"--\");\n    \n    return rows.join(\"\\r\\n\");\n    \n}\n\n/**\n * mail.EmailMessage#generateAddresses(addresses, limit, use_list) -> String\n * - addresses (String): Comma separated list of addresses\n * - limit (String): How many addresses will be used from the list\n * - use_list (String): property name where to add plain e-mail addresses\n * \n * Parses an address string, finds the data and normalizes it. If use_string\n * is set, (ie. \"toAddress\") then found e-mail addresses are appended to\n * a list with the same name (this.toAddress). Plain e-mail addresses are\n * needed for the SMTP server.\n **/\n\nEmailMessage.prototype.generateAddresses = function(addresses, limit, use_list){\n    var parsed, output = [], current;\n    \n    limit = limit || 0;\n    \n    try{\n        parsed = mimelib.parseAddresses(addresses);\n    }catch(E){parsed = [];}\n    \n    var list = [];\n    for(var i=0; i<parsed.length; i++){\n        current = parsed[i];\n        current.address = current.address && current.address.trim();\n        if(!current.address)continue;\n        \n        list.push(current.address);\n        \n        if(hasUTFChars(current.address)){\n            current.address = mimelib.encodeMimeWord(current.address, \"Q\");\n        }\n        \n        if(current.name){\n            current.name = upperFirst(current.name.trim(), true);\n            if(hasUTFChars(current.name)){\n                current.name = mimelib.encodeMimeWord(current.name, \"Q\");\n            }\n            current.name = '\"' + current.name + '\"';\n            current.address = '<' + current.address.trim() +'>';\n            output.push(current.name + \" \" +current.address);\n        }else{\n            output.push(current.address);\n        }\n    }\n\n    if(limit && output.length>limit){\n        output = output.slice(0, limit);\n        list = list.slice(0, limit);\n    }\n    \n    if(use_list){\n        if(!this[use_list]){\n            this[use_list] = list;\n        }else{\n            this[use_list] = this[use_list].concat(list);\n        }\n    }\n    \n    return output.join(\", \");\n}\n\n/**\n * mail.EmailMessage#send(callback) -> undefined\n * - callback (Function): function to be called if sending succeedes or fails\n * \n * Generates a full message body and forwards it to the SMTP server.\n * callback gets two params - error and success. If error is set, then\n * something bad happened, if there's no error but success is false, then\n * SMTP server failed and the message should be resent. If there's no error\n * and success is true, then the message was sent to the recipients\n **/\nEmailMessage.prototype.send = function(callback){\n    this.prepareVariables();\n    \n    var instanceId = ++instancecounter;\n    \n    if(this.debug){\n        var str = X_MAILER_NAME+\", \"+X_MAILER_VERSION+\", Node.js \"+process.version+\": \"+instanceId;\n        console.log(str);\n        console.log(Array(str.length+1).join(\"=\")+\"\\n\");\n    }\n    \n    // use sendmail if set\n    if(exports.sendmail){\n        var headers = this.generateHeaders(),\n            body = this.generateBody();\n\n        var path = typeof exports.sendmail==\"string\"?exports.sendmail:\"sendmail\";\n        exec('echo \"'+(headers+\"\\r\\n\\r\\n\"+body).replace(/\"/g,'\\\\\"')+'\" | '+path+\" -t\", function(error){\n            process.nextTick(function(){\n                if(error){\n                    callback && callback(error, null);\n                }else{\n                    callback && callback(null, true);\n                }\n            });\n        });\n       return;\n    }\n    \n    // use SERVER\n    var client = new SMTPClient(this.SERVER.host, this.SERVER.port, {\n            hostname: this.SERVER.hostname,\n            use_authentication: this.SERVER.use_authentication,\n            user: this.SERVER.user,\n            pass: this.SERVER.pass,\n            ssl: this.SERVER.ssl,\n            debug: this.debug,\n            instanceId: instanceId\n        });\n    \n    client.on(\"empty\",function() {\n        client.send(\"QUIT\",function() {\n            client.close();    \n        });\n    });\n    \n    client.on(\"connection_stable\", (function(){\n        this.emit.apply(this,[\"connection_stable\"].concat([].slice.call(arguments)));\n    }).bind(this));\n    \n    client.on(\"error\", function(error){\n        callback && callback(error, null);\n    });\n    \n    client.sendMail(this, callback);\n}\n\n/**\n * getMimeType(filename) -> String\n * - filename (String): Failinimi, mille mime tüüpi otsida\n * \n * Otsib välja faililaiendi alusel õige mime tüübi, vaikimisi\n * kui tüüpi ei leita on application/octet-stream\n **/\nfunction getMimeType(filename){\n    var defaultMime = \"application/octet-stream\",\n        extension = filename && filename.substr(filename.lastIndexOf(\".\")+1).trim().toLowerCase();\n    return extension && mimelib.contentTypes[extension] || defaultMime;\n}\n\n\n/**\n * upperFirst(str) -> String\n * - str (String): string to be converted\n * \n * Converts first letters upper case, other lower case\n * \n * \"x-name-value\" -> \"X-Name-Value\"\n * \n **/\nfunction upperFirst(str, keepUpper){\n    if(!keepUpper){\n        str = str.toLowerCase();\n    }\n    return str.replace(/^\\s*[a-z]|[\\-\\s][a-z]/g,function(c){\n        return c.toUpperCase()\n    });\n}\n\n/**\n * hasUTFChars(str) -> Boolean\n * - str (String): String to be checked for non-ascii chars\n * \n * Tries to detect if a string has non-ascii characters. In this case the\n * string needs to be encoded before sent to the SMTP server\n **/\nfunction hasUTFChars(str){\n    var rforeign = /[^\\u0000-\\u007f]/;\n    return !!rforeign.test(str);\n}\n\n/**\n * stripHTML(str) -> String\n * - str (String): HTML string to be converted\n * \n * Converts a HTML string into plain text\n **/\nfunction stripHTML(str){\n    if(!str)return str;\n    \n    str = str instanceof Buffer ? str.toString(\"utf-8\"):str;\n    \n    str = str.replace(/\\r?\\n/g,\" \");\n    str = str.replace(/<(?:\\/p|br|\\/tr|\\/table|\\/div)>/g,\"\\n\");\n\n    // hide newlines with two 00 chars (enables multiline matches)\n    str = str.replace(/\\r?\\n/g,\"-\\u0000\\u0000-\");\n    \n    // H1-H6, add underline\n    str = str.replace(/<[hH]\\d[^>]*>(.*?)<\\/[hH]\\d[^>]*>/g,function(a,b){\n        var line = \"\";\n        b = b.replace(/<[^>]*>/g,\" \");\n        b = b.replace(/\\s\\s+/g,\" \");\n        b = b.trim();\n        \n        if(!b)\n            return \"\";\n        for(var i=0, len = b.length; i<len; i++){\n            line+=\"-\";\n        }\n        return b+\"\\n\"+line+\"\\n\\n\";\n    });\n\n    // LI, indent by 2 spaces + *\n    str = str.replace(/<li[^>]*>(.*?)<\\/?(?:li|ol|ul)[^>]*>/ig,function(a,b){\n        b = b.replace(/<[^>]*>/g,\" \");\n        b = b.replace(/\\s\\s+/g,\" \");\n        b = b.trim();\n        \n        if(!b)\n            return \"\";\n        return \"-®®®®-* \"+b+\"\\n\";\n    });\n\n    // PRE, indent by 4 spaces\n    str = str.replace(/<pre[^>]*>(.*?)<\\/pre[^>]*>/ig,function(a,b){\n        b = b.replace(/<[^>]*>/g,\" \");\n        b = b.replace(/\\s\\s+/g,\" \");\n        b = b.trim();\n        \n        if(!b)\n            return \"\";\n\n        b = b.replace(/[ \\t]*\\n[ \\t]*/g,\"\\n-®®®®--®®®®-\");\n        \n        return \"\\n-®®®®--®®®®-\"+b.trim()+\"\\n\\n\";\n    });\n\n    // restore \n    str = str.replace(/\\s*-\\u0000\\u0000-\\s*/g,\"\\n\");\n    \n    // remove all remaining html tags\n    str = str.replace(/<[^>]*>/g,\" \");\n    // remove duplicate spaces\n    str = str.replace(/[ ][ ]+/g,\" \");\n    // remove spaces before and after newlines\n    str = str.replace(/[ \\t]*\\n[ \\t]*/g,\"\\n\");\n    // remove more than 2 newlines in a row\n    str = str.replace(/\\n\\n+/g,\"\\n\\n\");\n    // restore hidden spaces (four (r) signs for two spaces)\n    str = str.replace(/-®®®®-/g,\"  \");\n    return str.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsZ0hBQWlEO0FBQ2xFLGNBQWMsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDdkMsV0FBVyxnRUFBNkI7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLG1CQUFtQiwwREFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBDQUEwQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrQkFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekMseURBQXlELGtDQUFrQztBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNERBQTRELGtDQUFrQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGdFQUFnRSxrQ0FBa0M7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFNBQVM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhaWF1cmNvZGUvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbC5qcz81OGI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTTVRQQ2xpZW50ID0gZXhwb3J0cy5TTVRQQ2xpZW50ID0gcmVxdWlyZShcIi4vc210cFwiKS5TTVRQQ2xpZW50LFxuICAgIG1pbWVsaWIgPSByZXF1aXJlKFwibWltZWxpYi1ub2ljb252XCIpLFxuICAgIGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1xuICAgIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlclxuLypcbiAqIFZlcnNpb24gY29uc3RhbnRzXG4gKi9cbnZhciBYX01BSUxFUl9OQU1FID0gXCJOb2RlbWFpbGVyXCIsXG4gICAgWF9NQUlMRVJfVkVSU0lPTiA9IFwiMC4xLjIwOyAraHR0cDovL3d3dy5ub2RlbWFpbGVyLm9yZ1wiO1xuXG4vKipcbiAqIG1haWxcbiAqIFxuICogUHJvdmlkZXMgYW4gQVBJIHRvIHNlbmQgZS1tYWlscyB3aXRoIE5vZGUuanMgdGhyb3VnaCBhIFNNVFAgc2VydmVyLlxuICogVGhpcyBBUEkgaXMgdW5pY29kZSBmcmllbmRseSwgeW91IGRvbid0IGhhdmUgdG8gZXNjYXBlIG5vbi1hc2NpaSBjaGFycy5cbiAqIFxuICogTkIhIEJlZm9yZSBzZW5kaW5nIGFueSBlLW1haWxzLCB1cGRhdGUgbWFpbC5TTVRQIHdpdGggY29ycmVjdCB2YWx1ZXNcbiAqIFxuICoqL1xuXG5cbi8vIEVYUE9TRSBUTyBUSEUgV09STERcblxuLyoqXG4gKiBtYWlsLlNNVFAgLT4gT2JqZWN0XG4gKiBcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0LCBrZWVwcyB0aGUgbmVlZGVkIHZhbHVlcyB0byBjb25uZWN0IHRvIHRoZSBTTVRQIHNlcnZlclxuICogXG4gKiAgIC0gKipob3N0KiogSG9zdG5hbWUgb2YgdGhlIFNNVFAgc2VydmVyIChyZXF1aXJlZClcbiAqICAgLSAqKnBvcnQqKiBTTVRQIHNlcnZlciBwb3J0LCBkZWZhdWx0cyB0byAyNVxuICogICAtICoqaG9zdG5hbWUqKiBob3N0bmFtZSBvZiB0aGUgbG9jYWwgc2VydmVyLCBuZWVkZWQgZm9yIGlkZW50aWZ5aW5nLFxuICogICAgIGRlZmF1bHRzIHRvICp1bnRpdGxlZC5zZXJ2ZXIqXG4gKiAgIC0gKip1c2VfYXV0aGVudGljYXRpb24qKiBpZiBzZXQgdG8gKnRydWUqIGF1dGhlbnRpY2F0aW9uIHByb2NlZHVyZSBpc1xuICogICAgIHJ1biBhZnRlciBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICogICAtICoqdXNlcioqIHVzZXJuYW1lIGZvciBhdXRoZW50aWNhdGlvblxuICogICAtICoqcGFzcyoqIHBhc3N3b3JkIGZvciBhdXRoZW50aWNhdGlvblxuICoqL1xuZXhwb3J0cy5TTVRQID0ge1xuICAgIGhvc3Q6IGZhbHNlLFxuICAgIHBvcnQ6IGZhbHNlLFxuICAgIGhvc3RuYW1lOiBmYWxzZSxcbiAgICB1c2VfYXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgIHNzbDogZmFsc2UsXG4gICAgdXNlcjogZmFsc2UsXG4gICAgcGFzczogZmFsc2Vcbn07XG5cbmV4cG9ydHMuQ29tbW9uU2VydmVycyA9IHtcbiAgICBnbWFpbDpbXSxcbiAgICB5YWhvbzpbXSxcbiAgICBob3RtYWlsOltdXG59O1xuXG4vKipcbiAqIG1haWwuc2VuZG1haWwgLT4gQm9vbGVhbiB8IFN0cmluZ1xuICogXG4gKiBJZiBzZXQgdG8gdHJ1ZSwgXCJzZW5kbWFpbFwiIGNvbW1hbmQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgU01UUFxuICogSWYgdGhlIHZhbHVlIGlzIGEgU3RyaW5nIHRoZW4gaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBzZW5kbWFpbCBjb21tYW5kXG4gKiBcbiAqICAgICBtYWlsLnNlbmRtYWlsID0gdHJ1ZVxuICogXG4gKiBvclxuICogXG4gKiAgICAgbWFpbC5zZW5kbWFpbCA9IFwiL3BhdGgvdG8vc2VuZG1haWxcIlxuICoqL1xuZXhwb3J0cy5zZW5kbWFpbCA9IGZhbHNlO1xuXG4vLyBFeHBvc2UgRW1haWxNZXNzYWdlIGZvciB0aGUgd29ybGRcbmV4cG9ydHMuRW1haWxNZXNzYWdlID0gRW1haWxNZXNzYWdlO1xuXG4vKipcbiAqIG1haWwuc2VuZF9tYWlsKHBhcmFtcywgY2FsbGJhY2spIC0+IHVuZGVmaW5lZFxuICogLSBwYXJhbXMgKE9iamVjdCk6IGUtbWFpbCBkYXRhXG4gKiAtIGNhbGxiYWNrIChGdW5jdGlvbik6IHdpbGwgYmUgcnVuIGFmdGVyIGNvbXBsZXRpb25cbiAqIFxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gc2VuZCBlLW1haWxzLiBTZWUgRW1haWxNZXNzYWdlIGZvciBwYXJhbSBzdHJ1Y3R1cmVcbiAqKi9cbmV4cG9ydHMuc2VuZF9tYWlsID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjayl7XG4gICAgdmFyIGVtID0gbmV3IEVtYWlsTWVzc2FnZShwYXJhbXMpO1xuICAgIGVtLnNlbmQoY2FsbGJhY2spO1xuICAgIHJldHVybiBlbTtcbn07XG5cbnZhciBnZW5jb3VudGVyID0gMCxcbiAgICBpbnN0YW5jZWNvdW50ZXIgPSAwO1xuXG4vKipcbiAqIG5ldyBtYWlsLkVtYWlsTWVzc2FnZShwYXJhbXMpXG4gKiAtIHBhcmFtcyAoT2JqZWN0KTogbWVzc2FnZSBkYXRhIChjYW4gYmUgYWx0ZXJlZCBhZnRlcndhcmRzKVxuICogXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0byBzZW5kIGFuIGUtbWFpbC5cbiAqIFxuICogcGFyYW1zIGNhbiBob2xkIHRoZSBmb2xsb3dpbmcgZGF0YVxuICpcbiAqICAgLSAqKnNlcnZlcioqIHNlcnZlciB0byBzZW5kIG1lc3NhZ2UgdG8gKHdpbGwgZGVmYXVsdCB0byBleHBvcnRzLlNNVFApXG4gKiAgIC0gKipzZW5kZXIqKiBlLW1haWwgYWRkcmVzcyBvZiB0aGUgc2VuZGVyXG4gKiAgIC0gKipoZWFkZXJzKiogYW4gb2JqZWN0IHdpdGggY3VzdG9tIGhlYWRlcnMuXG4gKiAgICAgYHtcIlgtTXlwYXJhbVwiOiBcInRlc3RcIiwgXCJNZXNzYWdlLUlEXCI6XCIxMjM0NVwifWBcbiAqICAgLSAqKnRvKiogY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgVE86IGFkZHJlc3NlZXNcbiAqICAgLSAqKmNjKiogY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgQ0M6IGFkZHJlc3NlZXNcbiAqICAgLSAqKmJjYyoqIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIEJDQzogYWRkcmVzc2Vlc1xuICogICAtICoqcmVwbHlfdG8qKiBBIHJlcGx5LXRvIGFkZHJlc3NcbiAqICAgLSAqKnN1YmplY3QqKiBNZXNzYWdlIHN1YmplY3RcbiAqICAgLSAqKmJvZHkqKiBNZXNzYWdlIGJvZHkgaW4gcGxhaW4gdGV4dFxuICogICAtICoqaHRtbCoqIE1lc3NhZ2UgYm9keSBpbiBIVE1MIGZvcm1hdFxuICogICAtICoqYXR0YWNobWVudHMqKiBhbiBhcnJheSBvZiBhdHRhY2hlbWVudHMgb2Yge2ZpbGVuYW1lLCBjb250ZW50cywgY2lkfVxuICogICAgIGZpbGVuYW1lIChtYW5kYXRvcnkpIGlzIGEgU3RyaW5nLCBjb250ZW50cyBjYW4gYmUgU3RyaW5nIG9yIEJ1ZmZlcixcbiAqICAgICBjaWQgaXMgb3B0aW9uYWwuXG4gKiBcbiAqICAgLSAqKmRlYnVnKiogaWYgc2V0LCBvdXRwdXRzIHRoZSB3aG9sZSBjb21tdW5pY2F0aW9uIG9mIFNNVFAgc2VydmVyIHRvIGNvbnNvbGVcbiAqIFxuICogQWxsIHRoZSBwYXJhbXMgY2FuIGJlIGVkaXRlZC9hZGRlZCBhZnRlciBkZWZpbmluZyB0aGUgb2JqZWN0XG4gKlxuICogRXZlbnRzOlxuICogICAgIGZvcndhcmQob2xkQWRkcixuZXdBZGRyKSAtIHdhcyB0b2xkIHRvIHRyeSBuZXcgYWRkcmVzcyBieSBzZXJ2ZXIuXG4gKiAgICAgZGVmZXIoYWRkcikgLSBzZXJ2ZXIgdGFrZXMgcmVzcG9uc2liaWxpdHkgZm9yIGRlbGl2ZXJ5LlxuICogICAgIHJldGFpbihhZGRyKSAtIHVuYWJsZSB0byBzZW5kIHRvIG1haWxib3guXG4gKiBVc2FnZTpcbiAqICAgICB2YXIgZW0gPSBFbWFpbE1lc3NhZ2UoKTtcbiAqICAgICBlbS5zZW5kZXIgPSAnXCJBbmRyaXMgUmVpbm1hblwiIDxhbmRyaXNAbm9kZS5lZT4nXG4gKiAgICAgZW0udG8gPSAnYW5kcmlzQGtyZWF0YS5lZSdcbiAqICAgICBlbS5ib2R5ID0gXCJIZWxsbyB3b3JsZCFcIjtcbiAqICAgICBlbS5zZW5kKGZ1bmN0aW9uKGVycm9yLCBzdWNjZXNzKXt9KTtcbiAqICAgICBcbiAqICBOQiEgbWFpbC5TTVRQIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbnkgZS1tYWlscyFcbiAqKi9cbmZ1bmN0aW9uIEVtYWlsTWVzc2FnZShwYXJhbXMpe1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLlNFUlZFUiA9IHBhcmFtcy5zZXJ2ZXIgfHwgZXhwb3J0cy5TTVRQO1xuICAgIHRoaXMuc2VuZGVyID0gcGFyYW1zLnNlbmRlcjtcbiAgICB0aGlzLmhlYWRlcnMgPSBwYXJhbXMuaGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLnRvID0gcGFyYW1zLnRvO1xuICAgIHRoaXMuY2MgPSBwYXJhbXMuY2M7XG4gICAgdGhpcy5iY2MgPSBwYXJhbXMuYmNjO1xuICAgIHRoaXMucmVwbHlfdG8gPSBwYXJhbXMucmVwbHlfdG87XG4gICAgdGhpcy5zdWJqZWN0ID0gcGFyYW1zLnN1YmplY3QgfHzCoFwiXCI7XG4gICAgdGhpcy5ib2R5ID0gcGFyYW1zLmJvZHkgfHwgXCJcIjtcbiAgICB0aGlzLmh0bWwgPSBwYXJhbXMuaHRtbDtcbiAgICB0aGlzLmF0dGFjaG1lbnRzID0gcGFyYW1zLmF0dGFjaG1lbnRzIHx8IFtdO1xuICAgIFxuICAgIHRoaXMuZGVidWcgPSAhIXBhcmFtcy5kZWJ1ZztcbiAgICBcbiAgICB0aGlzLmNoYXJzZXQgPSBwYXJhbXMuY2hhcnNldCB8fCBcIlVURi04XCI7XG4gICAgdGhpcy5lbmNvZGluZyA9IHBhcmFtcy5lbmNvZGluZyB8fCBcInF1b3RlZC1wcmludGFibGVcIjtcbiAgICBcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbn1cbnZhciB1dGlsbGliID0gcmVxdWlyZShcInV0aWxcIik7XG51dGlsLmluaGVyaXRzKEVtYWlsTWVzc2FnZSxFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIG1haWwuRW1haWxNZXNzYWdlI3ByZXBhcmVWYXJpYWJsZXMoKSAtPiB1bmRlZmluZWRcbiAqIFxuICogUHJlcGFyZXMgc29tZSBuZWVkZWQgdmFyaWFibGVzXG4gKiovXG5FbWFpbE1lc3NhZ2UucHJvdG90eXBlLnByZXBhcmVWYXJpYWJsZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuaHRtbCB8fCB0aGlzLmF0dGFjaG1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMuY29udGVudF9tdWx0aXBhcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRlbnRfbWl4ZWQgPSAhIXRoaXMuYXR0YWNobWVudHMubGVuZ3RoO1xuICAgIC8vJz1fJyBpcyBub3QgdmFsaWQgcXVvdGVkIHByaW50YWJsZVxuICAgIC8vJz8nIGlzIG5vdCBpbiBhbnkga25vd24gYmFzZTY0IGV4dGVuc2lvblxuICAgICAgICB0aGlzLmNvbnRlbnRfYm91bmRhcnkgPSBcIi0tLS1OT0RFTUFJTEVSLT89X1wiKygrK2dlbmNvdW50ZXIpK1wiLVwiK0RhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBkZWZhdWx0cyB0byBtdWx0aXBhcnQvbWl4ZWQgYnV0IGlmIHRoZXJlJ3MgYXR0YWNobWVudHMgd2l0aCBjaWQgdmFsdWUgc2V0XG4gICAgICAgIC8vIHVzZSBtdWx0aXBhcnQvcmVsYXRlZCAtIG1haWwgY2xpZW50cyBoaWRlIHRoZSBkdXBsaWNhdGVzIHRoaXMgd2F5XG4gICAgICAgIHZhciBtaXhlZCA9IFwibWl4ZWRcIjtcbiAgICAgICAgZm9yKHZhciBpPTAsIGxlbj10aGlzLmF0dGFjaG1lbnRzLmxlbmd0aDsgaTxsZW47aSsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuYXR0YWNobWVudHNbaV0uY2lkKXtcbiAgICAgICAgICAgICAgICBtaXhlZCA9IFwicmVsYXRlZFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGVudF90eXBlID0gXCJtdWx0aXBhcnQvXCIrKHRoaXMuY29udGVudF9taXhlZD9taXhlZDpcImFsdGVybmF0aXZlXCIpK1xuICAgICAgICAgICAgICAgIFwiOyBib3VuZGFyeT1cXFwiXCIrdGhpcy5jb250ZW50X2JvdW5kYXJ5K1wiXFxcIlwiO1xuICAgIH1lbHNle1xuICAgICAgICB0aGlzLmNvbnRlbnRfbXVsdGlwYXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudF90eXBlID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVwiK3RoaXMuY2hhcnNldDtcbiAgICAgICAgdGhpcy5jb250ZW50X3RyYW5zZmVyX2VuY29kaW5nID0gdGhpcy5lbmNvZGluZzsgIC8vIENoYW5nZWQgZnJvbSBxdW90ZWQtcHJpbnRhYmxlOyA1LzIzLzIwMTEuXG4gICAgfVxufVxuXG4vKipcbiAqIG1haWwuRW1haWxNZXNzYWdlI2dlbmVyYXRlSGVhZGVycygpIC0+IFN0cmluZ1xuICogXG4gKiBHZW5lcmF0ZXMgYSBoZWFkZXIgc3RyaW5nIHdoZXJlIGxpbmVzIGFyZSBzZXBhcmF0ZWQgYnkgXFxyXFxuXG4gKiovXG5FbWFpbE1lc3NhZ2UucHJvdG90eXBlLmdlbmVyYXRlSGVhZGVycyA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBcbiAgICAvLyBNaW1lXG4gICAgaGVhZGVycy5wdXNoKFtcbiAgICAgICAgXCJYLU1haWxlclwiLFxuICAgICAgICBYX01BSUxFUl9OQU1FK1wiIChcIitYX01BSUxFUl9WRVJTSU9OK1wiKVwiXG4gICAgXS5qb2luKFwiOiBcIikpO1xuICAgIFxuICAgIC8vIGFkZCBjdXN0b21cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycyk7XG4gICAgZm9yKHZhciBpPTAsIGxlbj1rZXlzLmxlbmd0aDsgaTxsZW47IGkrKyl7XG4gICAgICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgICAgICB1cHBlckZpcnN0KGtleXNbaV0udHJpbSgpKSxcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1trZXlzW2ldXVxuICAgICAgICBdLmpvaW4oXCI6IFwiKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIERhdGVcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlO1xuICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgIHVwcGVyRmlyc3QoXCJEYXRlXCIpLFxuICAgICAgICBkYXRlLnRvR01UU3RyaW5nKClcbiAgICBdLmpvaW4oXCI6IFwiKSk7XG5cbiAgICAvLyBGcm9tXG4gICAgdmFyIGZyb20gPSB0aGlzLmdlbmVyYXRlQWRkcmVzc2VzKHRoaXMuc2VuZGVyLDEsIFwiZnJvbUFkZHJlc3NcIik7XG4gICAgaWYoZnJvbS5sZW5ndGgpe1xuICAgICAgICBoZWFkZXJzLnB1c2goW1xuICAgICAgICAgICAgdXBwZXJGaXJzdChcIkZyb21cIiksXG4gICAgICAgICAgICBmcm9tXG4gICAgICAgIF0uam9pbihcIjogXCIpKTsgICAgXG4gICAgfVxuICAgIFxuICAgIC8vIFRvXG4gICAgdmFyIHRvID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Nlcyh0aGlzLnRvLCAwLCBcInRvQWRkcmVzc1wiKTtcbiAgICBpZih0by5sZW5ndGgpe1xuICAgICAgICBoZWFkZXJzLnB1c2goW1xuICAgICAgICAgICAgdXBwZXJGaXJzdChcIlRvXCIpLFxuICAgICAgICAgICAgdG9cbiAgICAgICAgXS5qb2luKFwiOiBcIikpOyAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gQ0NcbiAgICB2YXIgY2MgPSB0aGlzLmdlbmVyYXRlQWRkcmVzc2VzKHRoaXMuY2MsIDAsIFwidG9BZGRyZXNzXCIpO1xuICAgIGlmKGNjLmxlbmd0aCl7XG4gICAgICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgICAgICB1cHBlckZpcnN0KFwiQ2NcIiksXG4gICAgICAgICAgICBjY1xuICAgICAgICBdLmpvaW4oXCI6IFwiKSk7ICAgIFxuICAgIH1cbiAgICBcbiAgICAvLyBCQ0NcbiAgICB2YXIgYmNjID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Nlcyh0aGlzLmJjYywgMCwgXCJ0b0FkZHJlc3NcIik7XG4gICAgaWYoZXhwb3J0cy5zZW5kbWFpbCAmJiBiY2MubGVuZ3RoKXtcbiAgICAgICAgaGVhZGVycy5wdXNoKFtcbiAgICAgICAgICAgIHVwcGVyRmlyc3QoXCJCY2NcIiksXG4gICAgICAgICAgICBiY2NcbiAgICAgICAgXS5qb2luKFwiOiBcIikpO1xuICAgIH1cblxuICAgIC8vUmVwbHktVG9cbiAgICB2YXIgcmVwbHlfdG8gPSB0aGlzLmdlbmVyYXRlQWRkcmVzc2VzKHRoaXMucmVwbHlfdG8sIDEpO1xuICAgIGlmKHJlcGx5X3RvLmxlbmd0aCl7XG4gICAgICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgICAgICB1cHBlckZpcnN0KFwiUmVwbHktVG9cIiksXG4gICAgICAgICAgICByZXBseV90b1xuICAgICAgICBdLmpvaW4oXCI6IFwiKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN1YmplY3RcbiAgICBoZWFkZXJzLnB1c2goW1xuICAgICAgICB1cHBlckZpcnN0KFwiU3ViamVjdFwiKSxcbiAgICAgICAgdGhpcy5zdWJqZWN0ICYmIChoYXNVVEZDaGFycyh0aGlzLnN1YmplY3QpICYmIFxuICAgICAgICAgICAgICBtaW1lbGliLmVuY29kZU1pbWVXb3JkKHRoaXMuc3ViamVjdCwgXCJRXCIpIHx8IHRoaXMuc3ViamVjdCkgfHzCoCcnXG4gICAgXS5qb2luKFwiOiBcIikpO1xuXG4gICAgLy8gTWltZVxuICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgIFwiTUlNRS1WZXJzaW9uXCIsXG4gICAgICAgIFwiMS4wXCJcbiAgICBdLmpvaW4oXCI6IFwiKSk7IFxuICAgIFxuICAgIC8vIENvbnRlbnQtdHlwZVxuICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCIsXG4gICAgICAgIHRoaXMuY29udGVudF90eXBlXG4gICAgXS5qb2luKFwiOiBcIikpOyBcbiAgICBcbiAgICBpZighdGhpcy5jb250ZW50X211bHRpcGFydCl7XG4gICAgICAgIGhlYWRlcnMucHVzaChbXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICAgICAgICAgIHRoaXMuY29udGVudF90cmFuc2Zlcl9lbmNvZGluZ1xuICAgICAgICBdLmpvaW4oXCI6IFwiKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIG91dHB1dFxuICAgIHJldHVybiBoZWFkZXJzLm1hcChmdW5jdGlvbihlbG0pe1xuICAgICAgICByZXR1cm4gbWltZWxpYi5mb2xkTGluZShlbG0pO1xuICAgIH0pLmpvaW4oXCJcXHJcXG5cIik7XG59XG5cbi8qKlxuICogbWFpbC5FbWFpbE1lc3NhZ2UjZ2VuZXJhdGVCb2R5KCkgLT4gU3RyaW5nXG4gKiBcbiAqIEdlbmVyYXRlcyBhIGJvZHkgc3RyaW5nLiBJZiB0aGlzIGlzIGEgbXVsdGlwYXJ0IG1lc3NhZ2UgdGhlbiBkaWZmZXJlbnRcbiAqIHBhcnRzIHdpbGwgYmUgc2VwYXJhdGVkIGJ5IGJvdW5kYXJ5LCBib2R5K2h0bWwgYXJlIHB1dCBpbnRvIHNlcGFyYXRlXG4gKiBtdWx0aXBhcnQvYWx0ZXJuYXRlIGJsb2NrXG4gKiovXG5FbWFpbE1lc3NhZ2UucHJvdG90eXBlLmdlbmVyYXRlQm9keSA9IGZ1bmN0aW9uKCl7XG5cbiAgICBpZighdGhpcy5jb250ZW50X211bHRpcGFydCl7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkgJiYgbWltZWxpYi5lbmNvZGVRdW90ZWRQcmludGFibGUodGhpcy5ib2R5KSB8fMKgXCJcIjtcbiAgICB9XG4gICAgXG4gICAgdmFyIGJvZHlfYm91bmRhcnkgPSB0aGlzLmNvbnRlbnRfbWl4ZWQ/XG4gICAgICAgICAgICBcIi0tLS1OT0RFTUFJTEVSLT89X1wiKygrK2dlbmNvdW50ZXIpK1wiLVwiK0RhdGUubm93KCk6XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRfYm91bmRhcnksXG4gICAgICAgIHJvd3MgPSBbXTtcbiAgICBcblxuICAgIGlmKHRoaXMuY29udGVudF9taXhlZCl7XG4gICAgICAgIHJvd3MucHVzaChcIi0tXCIrdGhpcy5jb250ZW50X2JvdW5kYXJ5KTtcbiAgICAgICAgcm93cy5wdXNoKFwiQ29udGVudC1UeXBlOiBtdWx0aXBhcnQvYWx0ZXJuYXRpdmU7IGJvdW5kYXJ5PVxcXCJcIitib2R5X2JvdW5kYXJ5K1wiXFxcIlwiKTtcbiAgICAgICAgcm93cy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICBcbiAgICBpZighdGhpcy5ib2R5LnRyaW0oKSAmJiB0aGlzLmh0bWwpe1xuICAgICAgICB0aGlzLmJvZHkgPSBzdHJpcEhUTUwodGhpcy5odG1sKTtcbiAgICB9XG4gICAgXG4gICAgLy8gYm9keVxuICAgIHJvd3MucHVzaChcIi0tXCIrYm9keV9ib3VuZGFyeSk7XG4gICAgcm93cy5wdXNoKFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PVwiK3RoaXMuY2hhcnNldCk7XG4gICAgcm93cy5wdXNoKFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogXCIrdGhpcy5lbmNvZGluZyk7IC8vIENoYW5nZWQgZnJvbSBxdW90ZWQtcHJpbnRhYmxlOyA1LzIzLzIwMTEuXG4gICAgcm93cy5wdXNoKFwiXCIpO1xuICAgIC8vIGRvdHMgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGRvdWJsZSBkb3RzXG4gICAgcm93cy5wdXNoKG1pbWVsaWIuZW5jb2RlUXVvdGVkUHJpbnRhYmxlKHRoaXMuYm9keS50cmltKCkpLnJlcGxhY2UoL15cXC4vZ20sJy4uJykpO1xuICAgIHJvd3MucHVzaChcIlwiKTtcbiAgICBcbiAgICAvLyBodG1sXG4gICAgaWYodGhpcy5odG1sKXtcbiAgICAgICAgcm93cy5wdXNoKFwiLS1cIitib2R5X2JvdW5kYXJ5KTtcbiAgICAgICAgcm93cy5wdXNoKFwiQ29udGVudC1UeXBlOiB0ZXh0L2h0bWw7IGNoYXJzZXQ9XCIrdGhpcy5jaGFyc2V0KTtcbiAgICAgICAgcm93cy5wdXNoKFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogXCIrdGhpcy5lbmNvZGluZyk7IC8vIENoYW5nZWQgZnJvbSBxdW90ZWQtcHJpbnRhYmxlOyA1LzIzLzIwMTEuXG4gICAgICAgIHJvd3MucHVzaChcIlwiKTtcbiAgICAgICAgcm93cy5wdXNoKG1pbWVsaWIuZW5jb2RlUXVvdGVkUHJpbnRhYmxlKHRoaXMuaHRtbC50cmltKCkpLnJlcGxhY2UoL15cXC4vZ20sJy4uJykpO1xuICAgICAgICByb3dzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIFxuICAgIGlmKHRoaXMuY29udGVudF9taXhlZCl7XG4gICAgICAgIHJvd3MucHVzaChcIi0tXCIrYm9keV9ib3VuZGFyeStcIi0tXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBhdHRhY2htZW50c1xuICAgIHZhciBjdXJyZW50O1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuYXR0YWNobWVudHMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgICBmaWxlbmFtZTogaGFzVVRGQ2hhcnModGhpcy5hdHRhY2htZW50c1tpXS5maWxlbmFtZSk/XG4gICAgICAgICAgICAgICAgICAgIG1pbWVsaWIuZW5jb2RlTWltZVdvcmQodGhpcy5hdHRhY2htZW50c1tpXS5maWxlbmFtZSwgXCJRXCIpOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRzW2ldLmZpbGVuYW1lLnJlcGxhY2UoL1wiL2csJycpLFxuICAgICAgICAgICAgbWltZV90eXBlOiBnZXRNaW1lVHlwZSh0aGlzLmF0dGFjaG1lbnRzW2ldLmZpbGVuYW1lKSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmF0dGFjaG1lbnRzW2ldLmNvbnRlbnRzIGluc3RhbmNlb2YgQnVmZmVyP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRzW2ldLmNvbnRlbnRzOlxuICAgICAgICAgICAgICAgICAgICBuZXcgQnVmZmVyKHRoaXMuYXR0YWNobWVudHNbaV0uY29udGVudHMsIFwidXRmLThcIiksXG4gICAgICAgICAgICBkaXNwb3NpdGlvbjogXCJhdHRhY2htZW50XCIsXG4gICAgICAgICAgICBjb250ZW50X2lkOiB0aGlzLmF0dGFjaG1lbnRzW2ldLmNpZCB8fCAoKCsrZ2VuY291bnRlcikrXCIuXCIrRGF0ZS5ub3coKStcIkBcIisodGhpcy5TRVJWRVIuaG9zdG5hbWUgfHwgXCJsb2NhbGhvc3RcIikpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcm93cy5wdXNoKFwiLS1cIit0aGlzLmNvbnRlbnRfYm91bmRhcnkpO1xuICAgICAgICBcbiAgICAgICAgcm93cy5wdXNoKFwiQ29udGVudC1UeXBlOiBcIitjdXJyZW50Lm1pbWVfdHlwZStcIjsgbmFtZT1cXFwiXCIrY3VycmVudC5maWxlbmFtZStcIlxcXCJcIik7XG4gICAgICAgIHJvd3MucHVzaChcIkNvbnRlbnQtRGlzcG9zaXRpb246IFwiK2N1cnJlbnQuZGlzcG9zaXRpb24rXCI7IGZpbGVuYW1lPVxcXCJcIitjdXJyZW50LmZpbGVuYW1lK1wiXFxcIlwiKTtcbiAgICAgICAgcm93cy5wdXNoKFwiQ29udGVudC1JRDogPFwiK2N1cnJlbnQuY29udGVudF9pZCtcIj5cIik7XG4gICAgICAgIFxuICAgICAgICByb3dzLnB1c2goXCJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiBiYXNlNjRcIik7XG4gICAgICAgIHJvd3MucHVzaChcIlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8qIENoYW5nZWQgdG8gY29uZm9ybSB3aXRoIFJGQy0yMDQ1IHNlY3Rpb24gNi43LiAqL1xuICAgICAgICByb3dzLnB1c2goY3VycmVudC5jb250ZW50cy50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC8uezc2fS9nLFwiJCZcXHJcXG5cIikpO1xuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgXG4gICAgcm93cy5wdXNoKFwiLS1cIit0aGlzLmNvbnRlbnRfYm91bmRhcnkrXCItLVwiKTtcbiAgICBcbiAgICByZXR1cm4gcm93cy5qb2luKFwiXFxyXFxuXCIpO1xuICAgIFxufVxuXG4vKipcbiAqIG1haWwuRW1haWxNZXNzYWdlI2dlbmVyYXRlQWRkcmVzc2VzKGFkZHJlc3NlcywgbGltaXQsIHVzZV9saXN0KSAtPiBTdHJpbmdcbiAqIC0gYWRkcmVzc2VzIChTdHJpbmcpOiBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBhZGRyZXNzZXNcbiAqIC0gbGltaXQgKFN0cmluZyk6IEhvdyBtYW55IGFkZHJlc3NlcyB3aWxsIGJlIHVzZWQgZnJvbSB0aGUgbGlzdFxuICogLSB1c2VfbGlzdCAoU3RyaW5nKTogcHJvcGVydHkgbmFtZSB3aGVyZSB0byBhZGQgcGxhaW4gZS1tYWlsIGFkZHJlc3Nlc1xuICogXG4gKiBQYXJzZXMgYW4gYWRkcmVzcyBzdHJpbmcsIGZpbmRzIHRoZSBkYXRhIGFuZCBub3JtYWxpemVzIGl0LiBJZiB1c2Vfc3RyaW5nXG4gKiBpcyBzZXQsIChpZS4gXCJ0b0FkZHJlc3NcIikgdGhlbiBmb3VuZCBlLW1haWwgYWRkcmVzc2VzIGFyZSBhcHBlbmRlZCB0b1xuICogYSBsaXN0IHdpdGggdGhlIHNhbWUgbmFtZSAodGhpcy50b0FkZHJlc3MpLiBQbGFpbiBlLW1haWwgYWRkcmVzc2VzIGFyZVxuICogbmVlZGVkIGZvciB0aGUgU01UUCBzZXJ2ZXIuXG4gKiovXG5cbkVtYWlsTWVzc2FnZS5wcm90b3R5cGUuZ2VuZXJhdGVBZGRyZXNzZXMgPSBmdW5jdGlvbihhZGRyZXNzZXMsIGxpbWl0LCB1c2VfbGlzdCl7XG4gICAgdmFyIHBhcnNlZCwgb3V0cHV0ID0gW10sIGN1cnJlbnQ7XG4gICAgXG4gICAgbGltaXQgPSBsaW1pdCB8fCAwO1xuICAgIFxuICAgIHRyeXtcbiAgICAgICAgcGFyc2VkID0gbWltZWxpYi5wYXJzZUFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIH1jYXRjaChFKXtwYXJzZWQgPSBbXTt9XG4gICAgXG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxwYXJzZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICBjdXJyZW50ID0gcGFyc2VkW2ldO1xuICAgICAgICBjdXJyZW50LmFkZHJlc3MgPSBjdXJyZW50LmFkZHJlc3MgJiYgY3VycmVudC5hZGRyZXNzLnRyaW0oKTtcbiAgICAgICAgaWYoIWN1cnJlbnQuYWRkcmVzcyljb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIGxpc3QucHVzaChjdXJyZW50LmFkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYoaGFzVVRGQ2hhcnMoY3VycmVudC5hZGRyZXNzKSl7XG4gICAgICAgICAgICBjdXJyZW50LmFkZHJlc3MgPSBtaW1lbGliLmVuY29kZU1pbWVXb3JkKGN1cnJlbnQuYWRkcmVzcywgXCJRXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjdXJyZW50Lm5hbWUpe1xuICAgICAgICAgICAgY3VycmVudC5uYW1lID0gdXBwZXJGaXJzdChjdXJyZW50Lm5hbWUudHJpbSgpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmKGhhc1VURkNoYXJzKGN1cnJlbnQubmFtZSkpe1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG1pbWVsaWIuZW5jb2RlTWltZVdvcmQoY3VycmVudC5uYW1lLCBcIlFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSAnXCInICsgY3VycmVudC5uYW1lICsgJ1wiJztcbiAgICAgICAgICAgIGN1cnJlbnQuYWRkcmVzcyA9ICc8JyArIGN1cnJlbnQuYWRkcmVzcy50cmltKCkgKyc+JztcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGN1cnJlbnQubmFtZSArIFwiIFwiICtjdXJyZW50LmFkZHJlc3MpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGN1cnJlbnQuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihsaW1pdCAmJiBvdXRwdXQubGVuZ3RoPmxpbWl0KXtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cbiAgICBcbiAgICBpZih1c2VfbGlzdCl7XG4gICAgICAgIGlmKCF0aGlzW3VzZV9saXN0XSl7XG4gICAgICAgICAgICB0aGlzW3VzZV9saXN0XSA9IGxpc3Q7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpc1t1c2VfbGlzdF0gPSB0aGlzW3VzZV9saXN0XS5jb25jYXQobGlzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiLCBcIik7XG59XG5cbi8qKlxuICogbWFpbC5FbWFpbE1lc3NhZ2Ujc2VuZChjYWxsYmFjaykgLT4gdW5kZWZpbmVkXG4gKiAtIGNhbGxiYWNrIChGdW5jdGlvbik6IGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiBzZW5kaW5nIHN1Y2NlZWRlcyBvciBmYWlsc1xuICogXG4gKiBHZW5lcmF0ZXMgYSBmdWxsIG1lc3NhZ2UgYm9keSBhbmQgZm9yd2FyZHMgaXQgdG8gdGhlIFNNVFAgc2VydmVyLlxuICogY2FsbGJhY2sgZ2V0cyB0d28gcGFyYW1zIC0gZXJyb3IgYW5kIHN1Y2Nlc3MuIElmIGVycm9yIGlzIHNldCwgdGhlblxuICogc29tZXRoaW5nIGJhZCBoYXBwZW5lZCwgaWYgdGhlcmUncyBubyBlcnJvciBidXQgc3VjY2VzcyBpcyBmYWxzZSwgdGhlblxuICogU01UUCBzZXJ2ZXIgZmFpbGVkIGFuZCB0aGUgbWVzc2FnZSBzaG91bGQgYmUgcmVzZW50LiBJZiB0aGVyZSdzIG5vIGVycm9yXG4gKiBhbmQgc3VjY2VzcyBpcyB0cnVlLCB0aGVuIHRoZSBtZXNzYWdlIHdhcyBzZW50IHRvIHRoZSByZWNpcGllbnRzXG4gKiovXG5FbWFpbE1lc3NhZ2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgdGhpcy5wcmVwYXJlVmFyaWFibGVzKCk7XG4gICAgXG4gICAgdmFyIGluc3RhbmNlSWQgPSArK2luc3RhbmNlY291bnRlcjtcbiAgICBcbiAgICBpZih0aGlzLmRlYnVnKXtcbiAgICAgICAgdmFyIHN0ciA9IFhfTUFJTEVSX05BTUUrXCIsIFwiK1hfTUFJTEVSX1ZFUlNJT04rXCIsIE5vZGUuanMgXCIrcHJvY2Vzcy52ZXJzaW9uK1wiOiBcIitpbnN0YW5jZUlkO1xuICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgICBjb25zb2xlLmxvZyhBcnJheShzdHIubGVuZ3RoKzEpLmpvaW4oXCI9XCIpK1wiXFxuXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyB1c2Ugc2VuZG1haWwgaWYgc2V0XG4gICAgaWYoZXhwb3J0cy5zZW5kbWFpbCl7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZW5lcmF0ZUhlYWRlcnMoKSxcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmdlbmVyYXRlQm9keSgpO1xuXG4gICAgICAgIHZhciBwYXRoID0gdHlwZW9mIGV4cG9ydHMuc2VuZG1haWw9PVwic3RyaW5nXCI/ZXhwb3J0cy5zZW5kbWFpbDpcInNlbmRtYWlsXCI7XG4gICAgICAgIGV4ZWMoJ2VjaG8gXCInKyhoZWFkZXJzK1wiXFxyXFxuXFxyXFxuXCIrYm9keSkucmVwbGFjZSgvXCIvZywnXFxcXFwiJykrJ1wiIHwgJytwYXRoK1wiIC10XCIsIGZ1bmN0aW9uKGVycm9yKXtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gdXNlIFNFUlZFUlxuICAgIHZhciBjbGllbnQgPSBuZXcgU01UUENsaWVudCh0aGlzLlNFUlZFUi5ob3N0LCB0aGlzLlNFUlZFUi5wb3J0LCB7XG4gICAgICAgICAgICBob3N0bmFtZTogdGhpcy5TRVJWRVIuaG9zdG5hbWUsXG4gICAgICAgICAgICB1c2VfYXV0aGVudGljYXRpb246IHRoaXMuU0VSVkVSLnVzZV9hdXRoZW50aWNhdGlvbixcbiAgICAgICAgICAgIHVzZXI6IHRoaXMuU0VSVkVSLnVzZXIsXG4gICAgICAgICAgICBwYXNzOiB0aGlzLlNFUlZFUi5wYXNzLFxuICAgICAgICAgICAgc3NsOiB0aGlzLlNFUlZFUi5zc2wsXG4gICAgICAgICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlSWRcbiAgICAgICAgfSk7XG4gICAgXG4gICAgY2xpZW50Lm9uKFwiZW1wdHlcIixmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpZW50LnNlbmQoXCJRVUlUXCIsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGllbnQuY2xvc2UoKTsgICAgXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGNsaWVudC5vbihcImNvbm5lY3Rpb25fc3RhYmxlXCIsIChmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcyxbXCJjb25uZWN0aW9uX3N0YWJsZVwiXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG4gICAgXG4gICAgY2xpZW50Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyb3Ipe1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfSk7XG4gICAgXG4gICAgY2xpZW50LnNlbmRNYWlsKHRoaXMsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBnZXRNaW1lVHlwZShmaWxlbmFtZSkgLT4gU3RyaW5nXG4gKiAtIGZpbGVuYW1lIChTdHJpbmcpOiBGYWlsaW5pbWksIG1pbGxlIG1pbWUgdMO8w7xwaSBvdHNpZGFcbiAqIFxuICogT3RzaWIgdsOkbGphIGZhaWxpbGFpZW5kaSBhbHVzZWwgw7VpZ2UgbWltZSB0w7zDvGJpLCB2YWlraW1pc2lcbiAqIGt1aSB0w7zDvHBpIGVpIGxlaXRhIG9uIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVxuICoqL1xuZnVuY3Rpb24gZ2V0TWltZVR5cGUoZmlsZW5hbWUpe1xuICAgIHZhciBkZWZhdWx0TWltZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgIGV4dGVuc2lvbiA9IGZpbGVuYW1lICYmIGZpbGVuYW1lLnN1YnN0cihmaWxlbmFtZS5sYXN0SW5kZXhPZihcIi5cIikrMSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbiAmJiBtaW1lbGliLmNvbnRlbnRUeXBlc1tleHRlbnNpb25dIHx8IGRlZmF1bHRNaW1lO1xufVxuXG5cbi8qKlxuICogdXBwZXJGaXJzdChzdHIpIC0+IFN0cmluZ1xuICogLSBzdHIgKFN0cmluZyk6IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAqIFxuICogQ29udmVydHMgZmlyc3QgbGV0dGVycyB1cHBlciBjYXNlLCBvdGhlciBsb3dlciBjYXNlXG4gKiBcbiAqIFwieC1uYW1lLXZhbHVlXCIgLT4gXCJYLU5hbWUtVmFsdWVcIlxuICogXG4gKiovXG5mdW5jdGlvbiB1cHBlckZpcnN0KHN0ciwga2VlcFVwcGVyKXtcbiAgICBpZigha2VlcFVwcGVyKXtcbiAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccypbYS16XXxbXFwtXFxzXVthLXpdL2csZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiBjLnRvVXBwZXJDYXNlKClcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBoYXNVVEZDaGFycyhzdHIpIC0+IEJvb2xlYW5cbiAqIC0gc3RyIChTdHJpbmcpOiBTdHJpbmcgdG8gYmUgY2hlY2tlZCBmb3Igbm9uLWFzY2lpIGNoYXJzXG4gKiBcbiAqIFRyaWVzIHRvIGRldGVjdCBpZiBhIHN0cmluZyBoYXMgbm9uLWFzY2lpIGNoYXJhY3RlcnMuIEluIHRoaXMgY2FzZSB0aGVcbiAqIHN0cmluZyBuZWVkcyB0byBiZSBlbmNvZGVkIGJlZm9yZSBzZW50IHRvIHRoZSBTTVRQIHNlcnZlclxuICoqL1xuZnVuY3Rpb24gaGFzVVRGQ2hhcnMoc3RyKXtcbiAgICB2YXIgcmZvcmVpZ24gPSAvW15cXHUwMDAwLVxcdTAwN2ZdLztcbiAgICByZXR1cm4gISFyZm9yZWlnbi50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogc3RyaXBIVE1MKHN0cikgLT4gU3RyaW5nXG4gKiAtIHN0ciAoU3RyaW5nKTogSFRNTCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKiBcbiAqIENvbnZlcnRzIGEgSFRNTCBzdHJpbmcgaW50byBwbGFpbiB0ZXh0XG4gKiovXG5mdW5jdGlvbiBzdHJpcEhUTUwoc3RyKXtcbiAgICBpZighc3RyKXJldHVybiBzdHI7XG4gICAgXG4gICAgc3RyID0gc3RyIGluc3RhbmNlb2YgQnVmZmVyID8gc3RyLnRvU3RyaW5nKFwidXRmLThcIik6c3RyO1xuICAgIFxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHI/XFxuL2csXCIgXCIpO1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88KD86XFwvcHxicnxcXC90cnxcXC90YWJsZXxcXC9kaXYpPi9nLFwiXFxuXCIpO1xuXG4gICAgLy8gaGlkZSBuZXdsaW5lcyB3aXRoIHR3byAwMCBjaGFycyAoZW5hYmxlcyBtdWx0aWxpbmUgbWF0Y2hlcylcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyP1xcbi9nLFwiLVxcdTAwMDBcXHUwMDAwLVwiKTtcbiAgICBcbiAgICAvLyBIMS1INiwgYWRkIHVuZGVybGluZVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88W2hIXVxcZFtePl0qPiguKj8pPFxcL1toSF1cXGRbXj5dKj4vZyxmdW5jdGlvbihhLGIpe1xuICAgICAgICB2YXIgbGluZSA9IFwiXCI7XG4gICAgICAgIGIgPSBiLnJlcGxhY2UoLzxbXj5dKj4vZyxcIiBcIik7XG4gICAgICAgIGIgPSBiLnJlcGxhY2UoL1xcc1xccysvZyxcIiBcIik7XG4gICAgICAgIGIgPSBiLnRyaW0oKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCFiKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGZvcih2YXIgaT0wLCBsZW4gPSBiLmxlbmd0aDsgaTxsZW47IGkrKyl7XG4gICAgICAgICAgICBsaW5lKz1cIi1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYitcIlxcblwiK2xpbmUrXCJcXG5cXG5cIjtcbiAgICB9KTtcblxuICAgIC8vIExJLCBpbmRlbnQgYnkgMiBzcGFjZXMgKyAqXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLzxsaVtePl0qPiguKj8pPFxcLz8oPzpsaXxvbHx1bClbXj5dKj4vaWcsZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgYiA9IGIucmVwbGFjZSgvPFtePl0qPi9nLFwiIFwiKTtcbiAgICAgICAgYiA9IGIucmVwbGFjZSgvXFxzXFxzKy9nLFwiIFwiKTtcbiAgICAgICAgYiA9IGIudHJpbSgpO1xuICAgICAgICBcbiAgICAgICAgaWYoIWIpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgcmV0dXJuIFwiLcKuwq7CrsKuLSogXCIrYitcIlxcblwiO1xuICAgIH0pO1xuXG4gICAgLy8gUFJFLCBpbmRlbnQgYnkgNCBzcGFjZXNcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvPHByZVtePl0qPiguKj8pPFxcL3ByZVtePl0qPi9pZyxmdW5jdGlvbihhLGIpe1xuICAgICAgICBiID0gYi5yZXBsYWNlKC88W14+XSo+L2csXCIgXCIpO1xuICAgICAgICBiID0gYi5yZXBsYWNlKC9cXHNcXHMrL2csXCIgXCIpO1xuICAgICAgICBiID0gYi50cmltKCk7XG4gICAgICAgIFxuICAgICAgICBpZighYilcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuXG4gICAgICAgIGIgPSBiLnJlcGxhY2UoL1sgXFx0XSpcXG5bIFxcdF0qL2csXCJcXG4twq7CrsKuwq4tLcKuwq7CrsKuLVwiKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBcIlxcbi3CrsKuwq7Cri0twq7CrsKuwq4tXCIrYi50cmltKCkrXCJcXG5cXG5cIjtcbiAgICB9KTtcblxuICAgIC8vIHJlc3RvcmUgXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xccyotXFx1MDAwMFxcdTAwMDAtXFxzKi9nLFwiXFxuXCIpO1xuICAgIFxuICAgIC8vIHJlbW92ZSBhbGwgcmVtYWluaW5nIGh0bWwgdGFnc1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88W14+XSo+L2csXCIgXCIpO1xuICAgIC8vIHJlbW92ZSBkdXBsaWNhdGUgc3BhY2VzXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1sgXVsgXSsvZyxcIiBcIik7XG4gICAgLy8gcmVtb3ZlIHNwYWNlcyBiZWZvcmUgYW5kIGFmdGVyIG5ld2xpbmVzXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1sgXFx0XSpcXG5bIFxcdF0qL2csXCJcXG5cIik7XG4gICAgLy8gcmVtb3ZlIG1vcmUgdGhhbiAyIG5ld2xpbmVzIGluIGEgcm93XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcblxcbisvZyxcIlxcblxcblwiKTtcbiAgICAvLyByZXN0b3JlIGhpZGRlbiBzcGFjZXMgKGZvdXIgKHIpIHNpZ25zIGZvciB0d28gc3BhY2VzKVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8twq7CrsKuwq4tL2csXCIgIFwiKTtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mail.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp.js":
/*!*********************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var netlib = __webpack_require__(/*! net */ \"net\"),\n    fslib = __webpack_require__(/*! fs */ \"fs\"),\n    utillib = __webpack_require__(/*! util */ \"util\"),\n    oslib = __webpack_require__(/*! os */ \"os\"),\n    tlslib = __webpack_require__(/*! tls */ \"tls\"),\n    EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter),\n    starttls = __webpack_require__(/*! ./starttls.js */ \"(rsc)/./node_modules/nodemailer/lib/starttls.js\");\n\n/**\n * smtp\n * \n * This module handles the connection and message passing to a SMTP\n * server. SMTP is a simple text based protocol. Server is usually listening\n * on port 25. The client opens up a connection to the server,\n * server responds with \"220 hostname message\" thus indicating that\n * it is up and working. All server messages begin with a status code,\n * where codes starting with 4 or 5 are errors and 2 and 3 are normal states.\n * Most commands can't be used before a successful HELO or EHLO response.\n * E-mail message is ended with a single period on a line of itself. To not\n * create confusion, all periods in the beginning of ordinary lines should\n * be replaced with double periods. \"\\r\\n.this\" -> \"\\r\\n..this\"\n * \n * Actual recipients for the message are not taken from the message source\n * (To: Cc: and Bcc: fields) but from RCPT TO: commands. If there is more than\n * one recipient then the command can be entered multiple times.\n * \n *     {client establishes connection to the server}\n *     S: 220 node.ee\n *     C: HELO client.hostname\n *     S: 250 Hello client.hostname\n *     C: MAIL FROM:<andris@node.ee>\n *     S: 250 Ok\n *     C: RCPT TO:<andris@kreata.ee>\n *     S: 250 Ok\n *     C: RCPT TO:<andris.reinman@gmail.com>\n *     S: 250 Ok\n *     C: DATA\n *     S: 354 End with <CR><LF>.<CR><LF>\n *     C: From: Andris Reinman <andris@node.ee>\\r\\n\n *        To: Andris Reinman <andris@kreata.ee>\\r\\n\n *        Cc: Andris Reinman <andris.reinman@gmail.com>\\r\\n\n *        Subject: Test\\r\\n\n *        \\r\\n\n *        Hello, I'm sending myself a test message\\r\\n\n *        .\\r\\n\n *     S: 250 Ok: queued as B7AD718D9DFF\n *     C: QUIT\n *     S: 221 Good bye\n *     {the server closes the connection} \n * \n **/\n\n// expose constructor SMTPClient to the world\nexports.SMTPClient = SMTPClient;\n\n\n/**\n * new smtp.SMTPClient(host, port[, options])\n * - host (String): SMTP server hostname\n * - port (Number): SMTP server port\n * - options (Object): optional additional settings\n * \n * Constructs a wrapper for a SMTP connection as an EventEmitter type object.\n * \n * options can include following data:\n * \n * - hostname (String): hostname of the sending server, needed for handshake\n *   defaults to OS hostname or \"localhost\"\n * - use_authentication (Boolean): is authorization needed, default is false\n * - ssl (Boolean): use SSL (port 465)\n * - user (String): the username if authorization is needed\n * - pass (String): the password if authorization is needed\n * \n * Authorization is somewhat problematic with Node.JS v0.3.x since it doesn't\n * support setSecure which is needed to enter TLS state AFTER non-encrypted\n * SMTP handshake. Most servers doesn't accept plaintext passwords without TLS. \n * \n * Supported events:\n * \n * - 'connect' if a connection is opened successfully\n * - 'connection_stable' when the connection is finalized and this._connection will stay the same (generally add listeners here).\n * - 'error' if an uncatched error occurs\n * - 'close' when the connection closes\n *     \n **/\nfunction SMTPClient(host, port, options){\n    \n    // Needed to convert this constructor into EventEmitter\n    EventEmitter.call(this);\n    \n    // Public properties\n    // -----------------\n    this.host = host || \"localhost\";\n    this.options = options || {};\n    this.port = port || (this.options.ssl && 465 || 25);\n    \n    // defaul hostname is machine hostname or [IP]\n    var defaultHostname = (oslib.hostname && oslib.hostname()) || \n                          (oslib.getHostname && oslib.getHostname()) ||\n                          \"\";\n    if(defaultHostname.indexOf('.')<0){\n        defaultHostname = \"[127.0.0.1]\";\n    }\n    if(defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)){\n        defaultHostname = \"[\"+defaultHostname+\"]\";\n    }\n    \n    this.hostname = this.options.hostname || defaultHostname;\n    \n    this.ignore_data = false; //Ignore data events while this is true (starttls)\n\n    this.debug = !!this.options.debug;\n    this.instanceId = this.options.instanceId || \"X\";\n\n    this.sending = false;\n    this.logged_in = false; // Used for queueing and flushing\n    this.remote_pipelining = false; // Is pipelining enabled\n    this.remote_starttls = false;   // Is TLS enabled, currently no effect\n    this.remote_extended = true;    // Does the server support EHLO or HELO\n    \n    this.remote_auth_plain = false;    // Does the server support AUTH PLAIN\n    this.remote_auth_login = false;    // Does the server support AUTH LOGIN\n\n    // Not so public properties\n    // ------------------------\n    this._connected = false;   // Indicates if an active connection is available\n    this._connection = false;  // Holds connection info\n    this._callbackQueue = [];  // Queues the responses FIFO (needed for pipelining)\n    this._messageQueue = []; // Queues the messages FIFO\n    this._data_remainder = \"\"; // Needed to group multi-line messages from server, string buffer to prevent newline issue.\n    this._timeoutTimer = null;\n}\n// Needed to convert this constructor into EventEmitter\nutillib.inherits(SMTPClient, EventEmitter);\n\n///////////// PUBLIC METHODS /////////////\n\nSMTPClient.prototype._flushMessages = function() {\n    \n    if(this.sending) return;\n    \n    var smtp = this,\n        message = this._messageQueue.shift();\n        \n    if(!message) {\n        this.emit(\"empty\");\n        return;\n    }\n    \n    var mail = message.message,\n        callback = message.callback;\n        \n    this.sending = true;\n    mail.prepareVariables();\n    \n    var headers = mail.generateHeaders(),\n        body = mail.generateBody(),\n        i = 0,\n        //concat if you need to do forwards\n        toAddress = mail.toAddress.concat(),\n        fromAddress = mail.fromAddress;\n    \n    process.nextTick(nextSender);\n        \n    // closured functions\n    \n    function nextSender(){\n        if(i === fromAddress.length) {\n            i = 0;\n            nextRecipient();\n        }else{\n            smtp.send(\"MAIL FROM:<\"+fromAddress[i++]+\">\", function(error, message) {\n                if(error) {\n                    smtp.close();\n                    process.nextTick(function(){\n                        callback && callback(error, null);\n                    });\n                    return;\n                }\n                process.nextTick(nextSender);\n            });\n        }\n    }\n    \n    function nextRecipient(){\n        var address;\n        if(i === toAddress.length) {\n            smtp.send(\"DATA\",function(error, message) {\n                process.nextTick(sendBody);\n            });\n        }else{\n            address = toAddress[i++];\n            smtp.send(\"RCPT TO:<\"+address+\">\", function(error, message) {\n                var forwardAddress;\n                if(error) {\n                    //Empty addresses are valid (for server sent notifications).\n                    if(forwardAddress = error.message.match(/^551.*try\\s+([<][^>]*[>])/)) {\n                        mail.emit(\"forward\", address,forwardAddress[1]);\n                        toAddress.splice(i,0,forwardAddress[1])\n                        process.nextTick(nextRecipient);\n                        return;\n                    }\n                    //Not all error codes are true failures (we may be able to still send it to other recipients)\n                    else if(error.message.match(/^(?:552|554|451|452|500|503|421)/)){\n                        smtp.close();\n                        process.nextTick(function(){\n                            callback && callback(error, null);\n                        });\n                        return;\n                    }else{\n                        mail.emit(\"retain\", address);\n                        process.nextTick(nextRecipient);\n                        return;\n                    }\n                }\n                \n                if(message && /^251/.test(message.test)) {\n                    mail.emit(\"defer\",address);\n                } else {\n                    mail.emit(\"send\",address);\n                }\n                process.nextTick(nextRecipient);\n                \n            });\n        }\n    }\n    \n    // Sends e-mail body to the SMTP server and finishes up\n    function sendBody(){\n        smtp.send(headers+\"\\r\\n\\r\\n\");\n        smtp.send(body);\n        smtp.send(\"\\r\\n.\", function(error, message){\n            if(!error){\n                smtp.sending = false;\n                smtp._flushMessages();\n                process.nextTick(function(){\n                    callback && callback(null, true);\n                });\n            }else{\n                smtp.close();\n                process.nextTick(function(){\n                    callback && callback(null, false);\n                });\n            }\n        });\n    }\n}\n\nSMTPClient.prototype.sendMail = function sendMail(message, callback) {\n    this._messageQueue.push({\n        message:message,\n        callback:callback\n    });\n    if(this._messageQueue.length === 1) this._flushMessages();\n}\n\n/**\n * smtp.SMTPClient#send(data, callback) -> undefined\n * - data (String): text to be sent to the SMTP server\n * - callback (Function): callback to be used, gets params error and message\n * \n * Main method for the SMTPClient object. Sends a string to the server and\n * if callback is set returns the response. If callback is not set then\n * the endline chars \\r\\n are not appended automatically\n * \n * NB! This function is Pipelining safe but you should check the support for\n * it if needed (#remote_pipelining).\n * \n * Usage:\n * \n *     smtpclient.send(\"EHLO hostname\", function(error, message){\n *         if(error){\n *             console.log(\"Server responded with error \"+error.message);\n *         }else{\n *             console.log(\"Server responded with \"+message);\n *         }\n *     });\n * \n *     smtpclient.send(\"From: andris@node.ee\\r\\nTo: andris@kreata.ee\\r\\nSubject: test\\r\\n\");\n * \n * If there is no connection to the SMTP server, one is created automatically\n **/\nSMTPClient.prototype.send = function(data, callback){\n\n    if(!this._connected){\n        return this._createConnection(this.send.bind(this, data, callback));\n    }\n\n    if(callback){\n        this._sendCommand(data, callback);\n    }else{\n        this._sendData(data);\n    }\n\n}\n\n/**\n * smtp.SMTPClient#close() -> undefined\n * \n * Closes the current connection to the server. For some reason needed after\n * the e-mail is sent (with QUIT) but might be server specific.\n **/\nSMTPClient.prototype.close = function(){\n    this._connected && this._connection && this._connection.end();\n    this._connected = false;\n};\n\n///////////// PRIVATE METHODS /////////////\n\n/**\n * smtp.SMTPClient#_sendCommand(data, callback) -> undefined\n * - data (String): string value to be sent to the SMTP server\n * - callback (Function): function to be run after the server has responded\n * \n * Sends a string to the server, appends \\r\\n to the end so this is not\n * meant to send data (mail body) but commands.\n **/\nSMTPClient.prototype._sendCommand = function(data, callback){\n    this._callbackQueue.push({callback: callback});\n    this._connection.write(data+\"\\r\\n\");\n    \n    if(this.debug)\n        console.log(\"SEND (\"+this.instanceId+\"):\\n└──\"+JSON.stringify(data+\"\\r\\n\"));\n}\n\n/**\n * smtp.SMTPClient#_sendData(data) -> undefined\n * - data (String): Text to be sent to the server\n * \n * Sends a string to the server. This is meant to send body data and such.\n **/\nSMTPClient.prototype._sendData = function(data){\n    this._connection.write(data);\n    \n    if(this.debug)\n        console.log(\"SEND (\"+this.instanceId+\"):\\n└──\"+JSON.stringify(data));\n}\n\n/**\n * smtp.SMTPClient#_loginHandler(callback) -> undefined\n * - callback (Function): function to be run after successful login\n * \n * If authentication is needed, performs AUTH PLAIN or AUTH LOGIN and runs the\n * callback function after success or emits error on fail.\n * This method is called by #_handshake after successful connection\n * \n * Callback is set by the caller of #_createConnection which forwards it\n * to #_handshake whic in turn forwards it to #_loginHandler\n **/\nSMTPClient.prototype._loginHandler = function(callback){\n    if(!this.options.use_authentication){\n        this.logged_in = true;\n        callback();\n    }else{\n        if(this.remote_auth_plain){\n            // use AUTH PLAIN\n            this._authPlain(callback);\n        }else if(this.remote_auth_login){\n            // use AUTH LOGIN\n            this._authLogin(callback);\n        }else{\n            // try AUTH PLAIN anyway\n            this._authPlain(callback);\n        }\n        // TODO: Add CRAM-MD5 authentication as well\n    }\n}\n\n/**\n * smtp.SMTPClient#_authLogin(callback) -> undefined\n * - callback (Function): function to be run after successful login\n *\n * Performs an AUTH PLAIN login\n * \n * C: AUTH PLAIN BASE64(user\\0user\\0pass)\n **/\nSMTPClient.prototype._authPlain = function(callback){\n    this.send(\"AUTH PLAIN \"+new Buffer(\n        this.options.user+\"\\u0000\"+\n        this.options.user+\"\\u0000\"+\n        this.options.pass).toString(\"base64\"), (function(error, message){\n        if(error){\n            this.emit(\"error\", error);\n            this.close();\n            return;\n        }\n        // login success\n        this.logged_in = true;\n        this.emit(\"auth\");\n        callback();\n    }).bind(this));\n}\n\n/**\n * smtp.SMTPClient#_authLogin(callback) -> undefined\n * - callback (Function): function to be run after successful login\n *\n * Performs an AUTH LOGIN login\n * \n * C: AUTH LOGIN\n * S: 334 VXNlcm5hbWU6\n * C: BASE64_ENCODED_USERNAME\n * S: 334 UGFzc3dvcmQ6\n * C: BASE64_ENCODED_PASSWORD\n **/\nSMTPClient.prototype._authLogin = function(callback){\n    var username = new Buffer(this.options.user).toString(\"base64\"),\n        password = new Buffer(this.options.pass).toString(\"base64\");\n\n    this.send(\"AUTH LOGIN\", (function(error, message){\n        if(error){\n            this.emit(\"error\", error);\n            this.close();\n            return;\n        }\n        // wait for base64 encoded 334 Username:\n        if(message.trim()!=\"334 VXNlcm5hbWU6\"){\n            this.emit(\"error\", new Error(\"Bad response from server - '\"+message.trim()+\n                        \"' while expecting for '334 VXNlcm5hbWU6'\"));\n            this.close();\n            return;\n        }\n        this.send(username, (function(error, message){\n            if(error){\n                this.emit(\"error\", error);\n                this.close();\n                return;\n            }\n            // wait for base64 encoded 334 Password:\n            if(message.trim()!=\"334 UGFzc3dvcmQ6\"){\n                this.emit(\"error\", new Error(\"Bad response from server - '\"+message.trim()+\n                            \"' while expecting for '334 UGFzc3dvcmQ6'\"));\n                this.close();\n                return;\n            }\n            this.send(password, (function(error, message){\n                if(error){\n                    this.emit(\"error\", error);\n                    this.close();\n                    return;\n                }\n                // login success\n                this.logged_in = true;\n                this.emit(\"auth\");\n                callback();\n            }).bind(this));\n        }).bind(this));\n    }).bind(this));\n}\n\n/**\n * smtp.SMTPClient#_dataListener(data) -> undefined\n * - data(String): String received from the server\n * \n * The default listener for incoming server messages. Checks if there's\n * no errors and runs a callback function from #_callbackQueue.\n * If the first char of the response is higher than 3 then the response\n * is considered erroneus.\n **/\nSMTPClient.prototype._dataListener = function(data){\n    if(this.debug) console.log(\"Routing Data (\"+this.instanceId+\")\");\n    var action = this._callbackQueue.shift();\n    var isError = +data.trim().charAt(0)>3;\n    if(action && action.callback){\n        if(isError){\n            action.callback(new Error(data), null);\n        }else{\n            action.callback(null, data);\n        }\n    }else{\n        if(isError){\n            this.emit(\"error\", new Error(data));\n            this.close();\n        }else{\n            // what the hell just happened? this should never occur\n        }\n    }\n}\n\n/**\n * smtp.SMTPClient#_handshakeListener(data) -> undefined\n * - data(String): String received from the server\n * \n * Server data listener for the handshake - waits for the 220 response\n * from the server (connection established).\n **/\nSMTPClient.prototype._handshakeListener = function(data, callback){\n    if(this.debug)\n        console.log(\"CONNECTION (\"+this.instanceId+\"): \"+data.toString(\"utf-8\").trim());\n    if(data.toString(\"utf-8\").trim().substr(0,3)==\"220\"){\n        this._connected = true; // connection established\n        \n        if(this.debug)\n            console.log(\"Connection established! (\"+this.instanceId+\")\");\n        \n        this._handshake(callback);\n    }else{\n        \n        if(this.debug)\n            console.log(\"Connection failed! (\"+this.instanceId+\")\");\n        \n        var error = new Error(\"Server responded with \"+data);\n        this.emit(\"error\", error);\n        this.close();\n        return;\n    }\n}\n\n/**\n * smtp.SMTPClient#_starttlsHandler(callback) -> undefined\n * - callback (Function): Function to be run after connection\n * \n * Initiates a TLS session with the server\n **/\nSMTPClient.prototype._starttlsHandler = function(callback){\n    if(this.debug){\n        console.log(\"STARTTLS: (\"+this.instanceId+\")\");\n    }\n    this._sendCommand(\"STARTTLS\", (function(error, data){\n        if(error){\n            this.emit(\"error\", error);\n            this.close();\n            return;\n        }\n        this.ignore_data = true;\n        var ssl_socket;\n        ssl_socket = starttls(this._connection, this.options, (function(){\n            \n            if(this.debug && !ssl_socket.authorized){\n                console.log(\"▒▒▒ WARNING: TLS ERROR (\"+ssl_socket.authorizationError+\") ▒▒▒\");\n            }\n            \n            ssl_socket.on(\"data\",this._onData);\n            this._connection.removeListener(\"data\",this._onData);\n            this._connection = ssl_socket;\n            this.ignore_data = false;\n            this._data_remainder = \"\";\n            this.emit(\"connection_stable\");\n            callback();\n        }).bind(this));\n    }).bind(this));\n}\n\n/**\n * smtp.SMTPClient#_handshake(callback) -> undefined\n * - callback (Function): will be forwarded to login after successful connection\n * \n * Will be run after a TCP connection to the server is established. Makes\n * a EHLO command (fallbacks to HELO on failure) and forwards the callback to\n * login function on success.\n **/\nSMTPClient.prototype._handshake = function(callback){\n    \n    this.emit(\"connect\");\n    this._sendCommand(\"EHLO \"+this.hostname, (function(error, data){\n        if(error){\n\n            // fallback to HELO\n            this._sendCommand(\"HELO \"+this.hostname, (function(error, data){\n                if(error){\n                    this.emit(\"error\", error);\n                    this.close();\n                    return;\n                }\n                this.remote_extended = false;\n                this._loginHandler(callback);    \n            }).bind(this));\n            \n        }\n        \n        // check for pipelining support\n        if(data.match(/PIPELINING/i)){\n            this.remote_pipelining = true;\n        }\n        \n        // check for pipelining support\n        if(data.match(/AUTH(?:\\s+[^\\n]*\\s+|\\s+)PLAIN/i)){\n            this.remote_auth_plain = true;\n        }\n        // check for pipelining support\n        if(data.match(/AUTH(?:\\s+[^\\n]*\\s+|\\s+)LOGIN/i)){\n            this.remote_auth_login = true;\n        }\n        \n        // check for TLS support\n        if(data.match(/STARTTLS/i)){\n            if(!this.remote_starttls) {\n                this.remote_starttls = true;\n                // start tls and rerun HELO\n                this._starttlsHandler(this._handshake.bind(this,callback));\n                return;\n            }\n        }\n\n        this.emit(\"connection_stable\");\n        // check login after successful handshake\n        this._loginHandler(callback);\n    }).bind(this));\n}\n\n/**\n * smtp.SMTPClient#_waitForTimeout() -> function\n * \n * Waits for 10 seconds after connection and if nothing happened emits an error\n **/\nSMTPClient.prototype._waitForTimeout = function(time){\n    clearTimeout(this._timeoutTimer);\n    this._timeoutTimer = setTimeout((function(){\n        this.emit(\"error\", new Error(\"Timeout waiting for response from server\"));\n        this.close();\n    }).bind(this), time || 10*1000);\n}\n\n/**\n * smtp.SMTPClient#_onData(data) -> function\n * - callback (Function): callback function to be used with connection\n * - data (Buffer): binary data from the server\n * \n * Receives binary data from the server, converts it to string and forwards\n * to a registered listener. Concatenates multiline messages etc.\n **/\nSMTPClient.prototype._onData = function(callback, data){\n\n    clearTimeout(this._timeoutTimer);\n\n    if(!this._connected){\n        return this._handshakeListener(data, callback);\n    }\n    \n    if(this.debug)\n        console.log(\"RECEIVE (\"+this.instanceId+\"):\\n└──\"+JSON.stringify(data.toString(\"utf-8\")),JSON.stringify(this._data_remainder));\n        \n    if(this.ignore_data) return undefined;\n    \n    //Have to do a concat to prevent the split issue where a data packet splits a line\n    //IE: \"1-\\r\\n2 \" with data packets \"1\" \"-\\r\\n2 \", using the split method\n    // becomes [\"1\",\"-\",\"2 \"]\n    this._data_remainder = (data.toString(\"utf-8\") + this._data_remainder);\n    var match = /(?:^\\d+.*$\\r?\\n)*?(?:^\\d+[\\ ].*(?:\\r?\\n|$))/m.exec(this._data_remainder);\n    if(match && match.index === 0) {\n        this._data_remainder = this._data_remainder.slice(match[0].length);\n        this._dataListener(match[0].replace(/^\\s*$/mg,\"\"));\n    }\n    \n    return undefined;\n}\n\n/**\n * smtp.SMTPClient#_createConnection(callback) -> function\n * - callback (Function): function to be run after successful connection,\n *   smtp handshake and login\n * \n * Creates a TCP connection to the SMTP server and sets up needed listeners.\n **/\nSMTPClient.prototype._createConnection = function(callback){\n    \n    if (this.options.ssl) {\n        this._connection = tlslib.connect(this.port, this.host);\n    } else {\n        this._connection = netlib.createConnection(this.port, this.host);\n    }\n\n    this._connection.on(\"end\", (function(){\n        this._connected = false;\n    }).bind(this));\n    \n    this._connection.on(\"close\", (function(){\n        this._connected = false;\n        this.emit(\"close\");\n    }).bind(this));\n    \n    this._connection.on(\"timeout\", (function(){\n        this.close();\n    }).bind(this));\n    \n    this._connection.on(\"error\", (function(error){\n        this.emit(\"error\", error);\n        this.close();\n    }).bind(this));\n    \n    //30 seconds to connect\n    this._waitForTimeout(30 * 1000);\n    //10 seconds for data\n    this._connection.on(\"connect\", this._waitForTimeout.bind(this));\n    this._connection.on(\"data\", this._onData = this._onData.bind(this, callback));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsZ0JBQUs7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLGNBQUk7QUFDeEIsY0FBYyxtQkFBTyxDQUFDLGtCQUFNO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxjQUFJO0FBQ3hCLGFBQWEsbUJBQU8sQ0FBQyxnQkFBSztBQUMxQixtQkFBbUIsMERBQThCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzRUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOzs7QUFHbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYWlhdXJjb2RlLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3NtdHAuanM/OWM2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbmV0bGliID0gcmVxdWlyZShcIm5ldFwiKSxcbiAgICBmc2xpYiA9IHJlcXVpcmUoXCJmc1wiKSxcbiAgICB1dGlsbGliID0gcmVxdWlyZShcInV0aWxcIiksXG4gICAgb3NsaWIgPSByZXF1aXJlKCdvcycpLFxuICAgIHRsc2xpYiA9IHJlcXVpcmUoJ3RscycpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcbiAgICBzdGFydHRscyA9IHJlcXVpcmUoJy4vc3RhcnR0bHMuanMnKTtcblxuLyoqXG4gKiBzbXRwXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gYW5kIG1lc3NhZ2UgcGFzc2luZyB0byBhIFNNVFBcbiAqIHNlcnZlci4gU01UUCBpcyBhIHNpbXBsZSB0ZXh0IGJhc2VkIHByb3RvY29sLiBTZXJ2ZXIgaXMgdXN1YWxseSBsaXN0ZW5pbmdcbiAqIG9uIHBvcnQgMjUuIFRoZSBjbGllbnQgb3BlbnMgdXAgYSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIsXG4gKiBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCBcIjIyMCBob3N0bmFtZSBtZXNzYWdlXCIgdGh1cyBpbmRpY2F0aW5nIHRoYXRcbiAqIGl0IGlzIHVwIGFuZCB3b3JraW5nLiBBbGwgc2VydmVyIG1lc3NhZ2VzIGJlZ2luIHdpdGggYSBzdGF0dXMgY29kZSxcbiAqIHdoZXJlIGNvZGVzIHN0YXJ0aW5nIHdpdGggNCBvciA1IGFyZSBlcnJvcnMgYW5kIDIgYW5kIDMgYXJlIG5vcm1hbCBzdGF0ZXMuXG4gKiBNb3N0IGNvbW1hbmRzIGNhbid0IGJlIHVzZWQgYmVmb3JlIGEgc3VjY2Vzc2Z1bCBIRUxPIG9yIEVITE8gcmVzcG9uc2UuXG4gKiBFLW1haWwgbWVzc2FnZSBpcyBlbmRlZCB3aXRoIGEgc2luZ2xlIHBlcmlvZCBvbiBhIGxpbmUgb2YgaXRzZWxmLiBUbyBub3RcbiAqIGNyZWF0ZSBjb25mdXNpb24sIGFsbCBwZXJpb2RzIGluIHRoZSBiZWdpbm5pbmcgb2Ygb3JkaW5hcnkgbGluZXMgc2hvdWxkXG4gKiBiZSByZXBsYWNlZCB3aXRoIGRvdWJsZSBwZXJpb2RzLiBcIlxcclxcbi50aGlzXCIgLT4gXCJcXHJcXG4uLnRoaXNcIlxuICogXG4gKiBBY3R1YWwgcmVjaXBpZW50cyBmb3IgdGhlIG1lc3NhZ2UgYXJlIG5vdCB0YWtlbiBmcm9tIHRoZSBtZXNzYWdlIHNvdXJjZVxuICogKFRvOiBDYzogYW5kIEJjYzogZmllbGRzKSBidXQgZnJvbSBSQ1BUIFRPOiBjb21tYW5kcy4gSWYgdGhlcmUgaXMgbW9yZSB0aGFuXG4gKiBvbmUgcmVjaXBpZW50IHRoZW4gdGhlIGNvbW1hbmQgY2FuIGJlIGVudGVyZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBcbiAqICAgICB7Y2xpZW50IGVzdGFibGlzaGVzIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlcn1cbiAqICAgICBTOiAyMjAgbm9kZS5lZVxuICogICAgIEM6IEhFTE8gY2xpZW50Lmhvc3RuYW1lXG4gKiAgICAgUzogMjUwIEhlbGxvIGNsaWVudC5ob3N0bmFtZVxuICogICAgIEM6IE1BSUwgRlJPTTo8YW5kcmlzQG5vZGUuZWU+XG4gKiAgICAgUzogMjUwIE9rXG4gKiAgICAgQzogUkNQVCBUTzo8YW5kcmlzQGtyZWF0YS5lZT5cbiAqICAgICBTOiAyNTAgT2tcbiAqICAgICBDOiBSQ1BUIFRPOjxhbmRyaXMucmVpbm1hbkBnbWFpbC5jb20+XG4gKiAgICAgUzogMjUwIE9rXG4gKiAgICAgQzogREFUQVxuICogICAgIFM6IDM1NCBFbmQgd2l0aCA8Q1I+PExGPi48Q1I+PExGPlxuICogICAgIEM6IEZyb206IEFuZHJpcyBSZWlubWFuIDxhbmRyaXNAbm9kZS5lZT5cXHJcXG5cbiAqICAgICAgICBUbzogQW5kcmlzIFJlaW5tYW4gPGFuZHJpc0BrcmVhdGEuZWU+XFxyXFxuXG4gKiAgICAgICAgQ2M6IEFuZHJpcyBSZWlubWFuIDxhbmRyaXMucmVpbm1hbkBnbWFpbC5jb20+XFxyXFxuXG4gKiAgICAgICAgU3ViamVjdDogVGVzdFxcclxcblxuICogICAgICAgIFxcclxcblxuICogICAgICAgIEhlbGxvLCBJJ20gc2VuZGluZyBteXNlbGYgYSB0ZXN0IG1lc3NhZ2VcXHJcXG5cbiAqICAgICAgICAuXFxyXFxuXG4gKiAgICAgUzogMjUwIE9rOiBxdWV1ZWQgYXMgQjdBRDcxOEQ5REZGXG4gKiAgICAgQzogUVVJVFxuICogICAgIFM6IDIyMSBHb29kIGJ5ZVxuICogICAgIHt0aGUgc2VydmVyIGNsb3NlcyB0aGUgY29ubmVjdGlvbn0gXG4gKiBcbiAqKi9cblxuLy8gZXhwb3NlIGNvbnN0cnVjdG9yIFNNVFBDbGllbnQgdG8gdGhlIHdvcmxkXG5leHBvcnRzLlNNVFBDbGllbnQgPSBTTVRQQ2xpZW50O1xuXG5cbi8qKlxuICogbmV3IHNtdHAuU01UUENsaWVudChob3N0LCBwb3J0Wywgb3B0aW9uc10pXG4gKiAtIGhvc3QgKFN0cmluZyk6IFNNVFAgc2VydmVyIGhvc3RuYW1lXG4gKiAtIHBvcnQgKE51bWJlcik6IFNNVFAgc2VydmVyIHBvcnRcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogb3B0aW9uYWwgYWRkaXRpb25hbCBzZXR0aW5nc1xuICogXG4gKiBDb25zdHJ1Y3RzIGEgd3JhcHBlciBmb3IgYSBTTVRQIGNvbm5lY3Rpb24gYXMgYW4gRXZlbnRFbWl0dGVyIHR5cGUgb2JqZWN0LlxuICogXG4gKiBvcHRpb25zIGNhbiBpbmNsdWRlIGZvbGxvd2luZyBkYXRhOlxuICogXG4gKiAtIGhvc3RuYW1lIChTdHJpbmcpOiBob3N0bmFtZSBvZiB0aGUgc2VuZGluZyBzZXJ2ZXIsIG5lZWRlZCBmb3IgaGFuZHNoYWtlXG4gKiAgIGRlZmF1bHRzIHRvIE9TIGhvc3RuYW1lIG9yIFwibG9jYWxob3N0XCJcbiAqIC0gdXNlX2F1dGhlbnRpY2F0aW9uIChCb29sZWFuKTogaXMgYXV0aG9yaXphdGlvbiBuZWVkZWQsIGRlZmF1bHQgaXMgZmFsc2VcbiAqIC0gc3NsIChCb29sZWFuKTogdXNlIFNTTCAocG9ydCA0NjUpXG4gKiAtIHVzZXIgKFN0cmluZyk6IHRoZSB1c2VybmFtZSBpZiBhdXRob3JpemF0aW9uIGlzIG5lZWRlZFxuICogLSBwYXNzIChTdHJpbmcpOiB0aGUgcGFzc3dvcmQgaWYgYXV0aG9yaXphdGlvbiBpcyBuZWVkZWRcbiAqIFxuICogQXV0aG9yaXphdGlvbiBpcyBzb21ld2hhdCBwcm9ibGVtYXRpYyB3aXRoIE5vZGUuSlMgdjAuMy54IHNpbmNlIGl0IGRvZXNuJ3RcbiAqIHN1cHBvcnQgc2V0U2VjdXJlIHdoaWNoIGlzIG5lZWRlZCB0byBlbnRlciBUTFMgc3RhdGUgQUZURVIgbm9uLWVuY3J5cHRlZFxuICogU01UUCBoYW5kc2hha2UuIE1vc3Qgc2VydmVycyBkb2Vzbid0IGFjY2VwdCBwbGFpbnRleHQgcGFzc3dvcmRzIHdpdGhvdXQgVExTLiBcbiAqIFxuICogU3VwcG9ydGVkIGV2ZW50czpcbiAqIFxuICogLSAnY29ubmVjdCcgaWYgYSBjb25uZWN0aW9uIGlzIG9wZW5lZCBzdWNjZXNzZnVsbHlcbiAqIC0gJ2Nvbm5lY3Rpb25fc3RhYmxlJyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGZpbmFsaXplZCBhbmQgdGhpcy5fY29ubmVjdGlvbiB3aWxsIHN0YXkgdGhlIHNhbWUgKGdlbmVyYWxseSBhZGQgbGlzdGVuZXJzIGhlcmUpLlxuICogLSAnZXJyb3InIGlmIGFuIHVuY2F0Y2hlZCBlcnJvciBvY2N1cnNcbiAqIC0gJ2Nsb3NlJyB3aGVuIHRoZSBjb25uZWN0aW9uIGNsb3Nlc1xuICogICAgIFxuICoqL1xuZnVuY3Rpb24gU01UUENsaWVudChob3N0LCBwb3J0LCBvcHRpb25zKXtcbiAgICBcbiAgICAvLyBOZWVkZWQgdG8gY29udmVydCB0aGlzIGNvbnN0cnVjdG9yIGludG8gRXZlbnRFbWl0dGVyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgXG4gICAgLy8gUHVibGljIHByb3BlcnRpZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuaG9zdCA9IGhvc3QgfHwgXCJsb2NhbGhvc3RcIjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucG9ydCA9IHBvcnQgfHwgKHRoaXMub3B0aW9ucy5zc2wgJiYgNDY1IHx8IDI1KTtcbiAgICBcbiAgICAvLyBkZWZhdWwgaG9zdG5hbWUgaXMgbWFjaGluZSBob3N0bmFtZSBvciBbSVBdXG4gICAgdmFyIGRlZmF1bHRIb3N0bmFtZSA9IChvc2xpYi5ob3N0bmFtZSAmJiBvc2xpYi5ob3N0bmFtZSgpKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9zbGliLmdldEhvc3RuYW1lICYmIG9zbGliLmdldEhvc3RuYW1lKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCI7XG4gICAgaWYoZGVmYXVsdEhvc3RuYW1lLmluZGV4T2YoJy4nKTwwKXtcbiAgICAgICAgZGVmYXVsdEhvc3RuYW1lID0gXCJbMTI3LjAuMC4xXVwiO1xuICAgIH1cbiAgICBpZihkZWZhdWx0SG9zdG5hbWUubWF0Y2goL15cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvKSl7XG4gICAgICAgIGRlZmF1bHRIb3N0bmFtZSA9IFwiW1wiK2RlZmF1bHRIb3N0bmFtZStcIl1cIjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMub3B0aW9ucy5ob3N0bmFtZSB8fCBkZWZhdWx0SG9zdG5hbWU7XG4gICAgXG4gICAgdGhpcy5pZ25vcmVfZGF0YSA9IGZhbHNlOyAvL0lnbm9yZSBkYXRhIGV2ZW50cyB3aGlsZSB0aGlzIGlzIHRydWUgKHN0YXJ0dGxzKVxuXG4gICAgdGhpcy5kZWJ1ZyA9ICEhdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IHRoaXMub3B0aW9ucy5pbnN0YW5jZUlkIHx8wqBcIlhcIjtcblxuICAgIHRoaXMuc2VuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VkX2luID0gZmFsc2U7IC8vIFVzZWQgZm9yIHF1ZXVlaW5nIGFuZCBmbHVzaGluZ1xuICAgIHRoaXMucmVtb3RlX3BpcGVsaW5pbmcgPSBmYWxzZTsgLy8gSXMgcGlwZWxpbmluZyBlbmFibGVkXG4gICAgdGhpcy5yZW1vdGVfc3RhcnR0bHMgPSBmYWxzZTsgICAvLyBJcyBUTFMgZW5hYmxlZCwgY3VycmVudGx5IG5vIGVmZmVjdFxuICAgIHRoaXMucmVtb3RlX2V4dGVuZGVkID0gdHJ1ZTsgICAgLy8gRG9lcyB0aGUgc2VydmVyIHN1cHBvcnQgRUhMTyBvciBIRUxPXG4gICAgXG4gICAgdGhpcy5yZW1vdGVfYXV0aF9wbGFpbiA9IGZhbHNlOyAgICAvLyBEb2VzIHRoZSBzZXJ2ZXIgc3VwcG9ydCBBVVRIIFBMQUlOXG4gICAgdGhpcy5yZW1vdGVfYXV0aF9sb2dpbiA9IGZhbHNlOyAgICAvLyBEb2VzIHRoZSBzZXJ2ZXIgc3VwcG9ydCBBVVRIIExPR0lOXG5cbiAgICAvLyBOb3Qgc28gcHVibGljIHByb3BlcnRpZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTsgICAvLyBJbmRpY2F0ZXMgaWYgYW4gYWN0aXZlIGNvbm5lY3Rpb24gaXMgYXZhaWxhYmxlXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGZhbHNlOyAgLy8gSG9sZHMgY29ubmVjdGlvbiBpbmZvXG4gICAgdGhpcy5fY2FsbGJhY2tRdWV1ZSA9IFtdOyAgLy8gUXVldWVzIHRoZSByZXNwb25zZXMgRklGTyAobmVlZGVkIGZvciBwaXBlbGluaW5nKVxuICAgIHRoaXMuX21lc3NhZ2VRdWV1ZSA9IFtdOyAvLyBRdWV1ZXMgdGhlIG1lc3NhZ2VzIEZJRk9cbiAgICB0aGlzLl9kYXRhX3JlbWFpbmRlciA9IFwiXCI7IC8vIE5lZWRlZCB0byBncm91cCBtdWx0aS1saW5lIG1lc3NhZ2VzIGZyb20gc2VydmVyLCBzdHJpbmcgYnVmZmVyIHRvIHByZXZlbnQgbmV3bGluZSBpc3N1ZS5cbiAgICB0aGlzLl90aW1lb3V0VGltZXIgPSBudWxsO1xufVxuLy8gTmVlZGVkIHRvIGNvbnZlcnQgdGhpcyBjb25zdHJ1Y3RvciBpbnRvIEV2ZW50RW1pdHRlclxudXRpbGxpYi5pbmhlcml0cyhTTVRQQ2xpZW50LCBFdmVudEVtaXR0ZXIpO1xuXG4vLy8vLy8vLy8vLy8vIFBVQkxJQyBNRVRIT0RTIC8vLy8vLy8vLy8vLy9cblxuU01UUENsaWVudC5wcm90b3R5cGUuX2ZsdXNoTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICBpZih0aGlzLnNlbmRpbmcpIHJldHVybjtcbiAgICBcbiAgICB2YXIgc210cCA9IHRoaXMsXG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgXG4gICAgaWYoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW1wdHlcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1haWwgPSBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgIGNhbGxiYWNrID0gbWVzc2FnZS5jYWxsYmFjaztcbiAgICAgICAgXG4gICAgdGhpcy5zZW5kaW5nID0gdHJ1ZTtcbiAgICBtYWlsLnByZXBhcmVWYXJpYWJsZXMoKTtcbiAgICBcbiAgICB2YXIgaGVhZGVycyA9IG1haWwuZ2VuZXJhdGVIZWFkZXJzKCksXG4gICAgICAgIGJvZHkgPSBtYWlsLmdlbmVyYXRlQm9keSgpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgLy9jb25jYXQgaWYgeW91IG5lZWQgdG8gZG8gZm9yd2FyZHNcbiAgICAgICAgdG9BZGRyZXNzID0gbWFpbC50b0FkZHJlc3MuY29uY2F0KCksXG4gICAgICAgIGZyb21BZGRyZXNzID0gbWFpbC5mcm9tQWRkcmVzcztcbiAgICBcbiAgICBwcm9jZXNzLm5leHRUaWNrKG5leHRTZW5kZXIpO1xuICAgICAgICBcbiAgICAvLyBjbG9zdXJlZCBmdW5jdGlvbnNcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0U2VuZGVyKCl7XG4gICAgICAgIGlmKGkgPT09IGZyb21BZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBuZXh0UmVjaXBpZW50KCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc210cC5zZW5kKFwiTUFJTCBGUk9NOjxcIitmcm9tQWRkcmVzc1tpKytdK1wiPlwiLCBmdW5jdGlvbihlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtdHAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5leHRTZW5kZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gbmV4dFJlY2lwaWVudCgpe1xuICAgICAgICB2YXIgYWRkcmVzcztcbiAgICAgICAgaWYoaSA9PT0gdG9BZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgc210cC5zZW5kKFwiREFUQVwiLGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhzZW5kQm9keSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBhZGRyZXNzID0gdG9BZGRyZXNzW2krK107XG4gICAgICAgICAgICBzbXRwLnNlbmQoXCJSQ1BUIFRPOjxcIithZGRyZXNzK1wiPlwiLCBmdW5jdGlvbihlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3J3YXJkQWRkcmVzcztcbiAgICAgICAgICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvL0VtcHR5IGFkZHJlc3NlcyBhcmUgdmFsaWQgKGZvciBzZXJ2ZXIgc2VudCBub3RpZmljYXRpb25zKS5cbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZEFkZHJlc3MgPSBlcnJvci5tZXNzYWdlLm1hdGNoKC9eNTUxLip0cnlcXHMrKFs8XVtePl0qWz5dKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsLmVtaXQoXCJmb3J3YXJkXCIsIGFkZHJlc3MsZm9yd2FyZEFkZHJlc3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGRyZXNzLnNwbGljZShpLDAsZm9yd2FyZEFkZHJlc3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5leHRSZWNpcGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vTm90IGFsbCBlcnJvciBjb2RlcyBhcmUgdHJ1ZSBmYWlsdXJlcyAod2UgbWF5IGJlIGFibGUgdG8gc3RpbGwgc2VuZCBpdCB0byBvdGhlciByZWNpcGllbnRzKVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGVycm9yLm1lc3NhZ2UubWF0Y2goL14oPzo1NTJ8NTU0fDQ1MXw0NTJ8NTAwfDUwM3w0MjEpLykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc210cC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWwuZW1pdChcInJldGFpblwiLCBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sobmV4dFJlY2lwaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobWVzc2FnZSAmJiAvXjI1MS8udGVzdChtZXNzYWdlLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWwuZW1pdChcImRlZmVyXCIsYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbC5lbWl0KFwic2VuZFwiLGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5leHRSZWNpcGllbnQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2VuZHMgZS1tYWlsIGJvZHkgdG8gdGhlIFNNVFAgc2VydmVyIGFuZCBmaW5pc2hlcyB1cFxuICAgIGZ1bmN0aW9uIHNlbmRCb2R5KCl7XG4gICAgICAgIHNtdHAuc2VuZChoZWFkZXJzK1wiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgICBzbXRwLnNlbmQoYm9keSk7XG4gICAgICAgIHNtdHAuc2VuZChcIlxcclxcbi5cIiwgZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2Upe1xuICAgICAgICAgICAgaWYoIWVycm9yKXtcbiAgICAgICAgICAgICAgICBzbXRwLnNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzbXRwLl9mbHVzaE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNtdHAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5zZW5kTWFpbCA9IGZ1bmN0aW9uIHNlbmRNYWlsKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbWVzc2FnZVF1ZXVlLnB1c2goe1xuICAgICAgICBtZXNzYWdlOm1lc3NhZ2UsXG4gICAgICAgIGNhbGxiYWNrOmNhbGxiYWNrXG4gICAgfSk7XG4gICAgaWYodGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aCA9PT0gMSkgdGhpcy5fZmx1c2hNZXNzYWdlcygpO1xufVxuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNzZW5kKGRhdGEsIGNhbGxiYWNrKSAtPiB1bmRlZmluZWRcbiAqIC0gZGF0YSAoU3RyaW5nKTogdGV4dCB0byBiZSBzZW50IHRvIHRoZSBTTVRQIHNlcnZlclxuICogLSBjYWxsYmFjayAoRnVuY3Rpb24pOiBjYWxsYmFjayB0byBiZSB1c2VkLCBnZXRzIHBhcmFtcyBlcnJvciBhbmQgbWVzc2FnZVxuICogXG4gKiBNYWluIG1ldGhvZCBmb3IgdGhlIFNNVFBDbGllbnQgb2JqZWN0LiBTZW5kcyBhIHN0cmluZyB0byB0aGUgc2VydmVyIGFuZFxuICogaWYgY2FsbGJhY2sgaXMgc2V0IHJldHVybnMgdGhlIHJlc3BvbnNlLiBJZiBjYWxsYmFjayBpcyBub3Qgc2V0IHRoZW5cbiAqIHRoZSBlbmRsaW5lIGNoYXJzIFxcclxcbiBhcmUgbm90IGFwcGVuZGVkIGF1dG9tYXRpY2FsbHlcbiAqIFxuICogTkIhIFRoaXMgZnVuY3Rpb24gaXMgUGlwZWxpbmluZyBzYWZlIGJ1dCB5b3Ugc2hvdWxkIGNoZWNrIHRoZSBzdXBwb3J0IGZvclxuICogaXQgaWYgbmVlZGVkICgjcmVtb3RlX3BpcGVsaW5pbmcpLlxuICogXG4gKiBVc2FnZTpcbiAqIFxuICogICAgIHNtdHBjbGllbnQuc2VuZChcIkVITE8gaG9zdG5hbWVcIiwgZnVuY3Rpb24oZXJyb3IsIG1lc3NhZ2Upe1xuICogICAgICAgICBpZihlcnJvcil7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBcIitlcnJvci5tZXNzYWdlKTtcbiAqICAgICAgICAgfWVsc2V7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZlciByZXNwb25kZWQgd2l0aCBcIittZXNzYWdlKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogXG4gKiAgICAgc210cGNsaWVudC5zZW5kKFwiRnJvbTogYW5kcmlzQG5vZGUuZWVcXHJcXG5UbzogYW5kcmlzQGtyZWF0YS5lZVxcclxcblN1YmplY3Q6IHRlc3RcXHJcXG5cIik7XG4gKiBcbiAqIElmIHRoZXJlIGlzIG5vIGNvbm5lY3Rpb24gdG8gdGhlIFNNVFAgc2VydmVyLCBvbmUgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5XG4gKiovXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spe1xuXG4gICAgaWYoIXRoaXMuX2Nvbm5lY3RlZCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVDb25uZWN0aW9uKHRoaXMuc2VuZC5iaW5kKHRoaXMsIGRhdGEsIGNhbGxiYWNrKSk7XG4gICAgfVxuXG4gICAgaWYoY2FsbGJhY2spe1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZChkYXRhLCBjYWxsYmFjayk7XG4gICAgfWVsc2V7XG4gICAgICAgIHRoaXMuX3NlbmREYXRhKGRhdGEpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNjbG9zZSgpIC0+IHVuZGVmaW5lZFxuICogXG4gKiBDbG9zZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyLiBGb3Igc29tZSByZWFzb24gbmVlZGVkIGFmdGVyXG4gKiB0aGUgZS1tYWlsIGlzIHNlbnQgKHdpdGggUVVJVCkgYnV0IG1pZ2h0IGJlIHNlcnZlciBzcGVjaWZpYy5cbiAqKi9cblNNVFBDbGllbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jb25uZWN0ZWQgJiYgdGhpcy5fY29ubmVjdGlvbiAmJiB0aGlzLl9jb25uZWN0aW9uLmVuZCgpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xufTtcblxuLy8vLy8vLy8vLy8vLyBQUklWQVRFIE1FVEhPRFMgLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNfc2VuZENvbW1hbmQoZGF0YSwgY2FsbGJhY2spIC0+IHVuZGVmaW5lZFxuICogLSBkYXRhIChTdHJpbmcpOiBzdHJpbmcgdmFsdWUgdG8gYmUgc2VudCB0byB0aGUgU01UUCBzZXJ2ZXJcbiAqIC0gY2FsbGJhY2sgKEZ1bmN0aW9uKTogZnVuY3Rpb24gdG8gYmUgcnVuIGFmdGVyIHRoZSBzZXJ2ZXIgaGFzIHJlc3BvbmRlZFxuICogXG4gKiBTZW5kcyBhIHN0cmluZyB0byB0aGUgc2VydmVyLCBhcHBlbmRzIFxcclxcbiB0byB0aGUgZW5kIHNvIHRoaXMgaXMgbm90XG4gKiBtZWFudCB0byBzZW5kIGRhdGEgKG1haWwgYm9keSkgYnV0IGNvbW1hbmRzLlxuICoqL1xuU01UUENsaWVudC5wcm90b3R5cGUuX3NlbmRDb21tYW5kID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spe1xuICAgIHRoaXMuX2NhbGxiYWNrUXVldWUucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShkYXRhK1wiXFxyXFxuXCIpO1xuICAgIFxuICAgIGlmKHRoaXMuZGVidWcpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU0VORCAoXCIrdGhpcy5pbnN0YW5jZUlkK1wiKTpcXG7ilJTilIDilIBcIitKU09OLnN0cmluZ2lmeShkYXRhK1wiXFxyXFxuXCIpKTtcbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX3NlbmREYXRhKGRhdGEpIC0+IHVuZGVmaW5lZFxuICogLSBkYXRhIChTdHJpbmcpOiBUZXh0IHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICogXG4gKiBTZW5kcyBhIHN0cmluZyB0byB0aGUgc2VydmVyLiBUaGlzIGlzIG1lYW50IHRvIHNlbmQgYm9keSBkYXRhIGFuZCBzdWNoLlxuICoqL1xuU01UUENsaWVudC5wcm90b3R5cGUuX3NlbmREYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShkYXRhKTtcbiAgICBcbiAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlNFTkQgKFwiK3RoaXMuaW5zdGFuY2VJZCtcIik6XFxu4pSU4pSA4pSAXCIrSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNfbG9naW5IYW5kbGVyKGNhbGxiYWNrKSAtPiB1bmRlZmluZWRcbiAqIC0gY2FsbGJhY2sgKEZ1bmN0aW9uKTogZnVuY3Rpb24gdG8gYmUgcnVuIGFmdGVyIHN1Y2Nlc3NmdWwgbG9naW5cbiAqIFxuICogSWYgYXV0aGVudGljYXRpb24gaXMgbmVlZGVkLCBwZXJmb3JtcyBBVVRIIFBMQUlOIG9yIEFVVEggTE9HSU4gYW5kIHJ1bnMgdGhlXG4gKiBjYWxsYmFjayBmdW5jdGlvbiBhZnRlciBzdWNjZXNzIG9yIGVtaXRzIGVycm9yIG9uIGZhaWwuXG4gKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgI19oYW5kc2hha2UgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gKiBcbiAqIENhbGxiYWNrIGlzIHNldCBieSB0aGUgY2FsbGVyIG9mICNfY3JlYXRlQ29ubmVjdGlvbiB3aGljaCBmb3J3YXJkcyBpdFxuICogdG8gI19oYW5kc2hha2Ugd2hpYyBpbiB0dXJuIGZvcndhcmRzIGl0IHRvICNfbG9naW5IYW5kbGVyXG4gKiovXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5fbG9naW5IYW5kbGVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLm9wdGlvbnMudXNlX2F1dGhlbnRpY2F0aW9uKXtcbiAgICAgICAgdGhpcy5sb2dnZWRfaW4gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1lbHNle1xuICAgICAgICBpZih0aGlzLnJlbW90ZV9hdXRoX3BsYWluKXtcbiAgICAgICAgICAgIC8vIHVzZSBBVVRIIFBMQUlOXG4gICAgICAgICAgICB0aGlzLl9hdXRoUGxhaW4oY2FsbGJhY2spO1xuICAgICAgICB9ZWxzZSBpZih0aGlzLnJlbW90ZV9hdXRoX2xvZ2luKXtcbiAgICAgICAgICAgIC8vIHVzZSBBVVRIIExPR0lOXG4gICAgICAgICAgICB0aGlzLl9hdXRoTG9naW4oY2FsbGJhY2spO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIHRyeSBBVVRIIFBMQUlOIGFueXdheVxuICAgICAgICAgICAgdGhpcy5fYXV0aFBsYWluKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBBZGQgQ1JBTS1NRDUgYXV0aGVudGljYXRpb24gYXMgd2VsbFxuICAgIH1cbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX2F1dGhMb2dpbihjYWxsYmFjaykgLT4gdW5kZWZpbmVkXG4gKiAtIGNhbGxiYWNrIChGdW5jdGlvbik6IGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBzdWNjZXNzZnVsIGxvZ2luXG4gKlxuICogUGVyZm9ybXMgYW4gQVVUSCBQTEFJTiBsb2dpblxuICogXG4gKiBDOiBBVVRIIFBMQUlOIEJBU0U2NCh1c2VyXFwwdXNlclxcMHBhc3MpXG4gKiovXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5fYXV0aFBsYWluID0gZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIHRoaXMuc2VuZChcIkFVVEggUExBSU4gXCIrbmV3IEJ1ZmZlcihcbiAgICAgICAgdGhpcy5vcHRpb25zLnVzZXIrXCJcXHUwMDAwXCIrXG4gICAgICAgIHRoaXMub3B0aW9ucy51c2VyK1wiXFx1MDAwMFwiK1xuICAgICAgICB0aGlzLm9wdGlvbnMucGFzcykudG9TdHJpbmcoXCJiYXNlNjRcIiksIChmdW5jdGlvbihlcnJvciwgbWVzc2FnZSl7XG4gICAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dpbiBzdWNjZXNzXG4gICAgICAgIHRoaXMubG9nZ2VkX2luID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYXV0aFwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX2F1dGhMb2dpbihjYWxsYmFjaykgLT4gdW5kZWZpbmVkXG4gKiAtIGNhbGxiYWNrIChGdW5jdGlvbik6IGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBzdWNjZXNzZnVsIGxvZ2luXG4gKlxuICogUGVyZm9ybXMgYW4gQVVUSCBMT0dJTiBsb2dpblxuICogXG4gKiBDOiBBVVRIIExPR0lOXG4gKiBTOiAzMzQgVlhObGNtNWhiV1U2XG4gKiBDOiBCQVNFNjRfRU5DT0RFRF9VU0VSTkFNRVxuICogUzogMzM0IFVHRnpjM2R2Y21RNlxuICogQzogQkFTRTY0X0VOQ09ERURfUEFTU1dPUkRcbiAqKi9cblNNVFBDbGllbnQucHJvdG90eXBlLl9hdXRoTG9naW4gPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgdmFyIHVzZXJuYW1lID0gbmV3IEJ1ZmZlcih0aGlzLm9wdGlvbnMudXNlcikudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcih0aGlzLm9wdGlvbnMucGFzcykudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbiAgICB0aGlzLnNlbmQoXCJBVVRIIExPR0lOXCIsIChmdW5jdGlvbihlcnJvciwgbWVzc2FnZSl7XG4gICAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWl0IGZvciBiYXNlNjQgZW5jb2RlZCAzMzQgVXNlcm5hbWU6XG4gICAgICAgIGlmKG1lc3NhZ2UudHJpbSgpIT1cIjMzNCBWWE5sY201aGJXVTZcIil7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJCYWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIgLSAnXCIrbWVzc2FnZS50cmltKCkrXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicgd2hpbGUgZXhwZWN0aW5nIGZvciAnMzM0IFZYTmxjbTVoYldVNidcIikpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZCh1c2VybmFtZSwgKGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKXtcbiAgICAgICAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGJhc2U2NCBlbmNvZGVkIDMzNCBQYXNzd29yZDpcbiAgICAgICAgICAgIGlmKG1lc3NhZ2UudHJpbSgpIT1cIjMzNCBVR0Z6YzNkdmNtUTZcIil7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKFwiQmFkIHJlc3BvbnNlIGZyb20gc2VydmVyIC0gJ1wiK21lc3NhZ2UudHJpbSgpK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJyB3aGlsZSBleHBlY3RpbmcgZm9yICczMzQgVUdGemMzZHZjbVE2J1wiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZChwYXNzd29yZCwgKGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKXtcbiAgICAgICAgICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvZ2luIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlZF9pbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYXV0aFwiKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0pLmJpbmQodGhpcykpO1xufVxuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNfZGF0YUxpc3RlbmVyKGRhdGEpIC0+IHVuZGVmaW5lZFxuICogLSBkYXRhKFN0cmluZyk6IFN0cmluZyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogVGhlIGRlZmF1bHQgbGlzdGVuZXIgZm9yIGluY29taW5nIHNlcnZlciBtZXNzYWdlcy4gQ2hlY2tzIGlmIHRoZXJlJ3NcbiAqIG5vIGVycm9ycyBhbmQgcnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gI19jYWxsYmFja1F1ZXVlLlxuICogSWYgdGhlIGZpcnN0IGNoYXIgb2YgdGhlIHJlc3BvbnNlIGlzIGhpZ2hlciB0aGFuIDMgdGhlbiB0aGUgcmVzcG9uc2VcbiAqIGlzIGNvbnNpZGVyZWQgZXJyb25ldXMuXG4gKiovXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5fZGF0YUxpc3RlbmVyID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgaWYodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coXCJSb3V0aW5nIERhdGEgKFwiK3RoaXMuaW5zdGFuY2VJZCtcIilcIik7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXMuX2NhbGxiYWNrUXVldWUuc2hpZnQoKTtcbiAgICB2YXIgaXNFcnJvciA9ICtkYXRhLnRyaW0oKS5jaGFyQXQoMCk+MztcbiAgICBpZihhY3Rpb24gJiYgYWN0aW9uLmNhbGxiYWNrKXtcbiAgICAgICAgaWYoaXNFcnJvcil7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbGJhY2sobmV3IEVycm9yKGRhdGEpLCBudWxsKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICAgaWYoaXNFcnJvcil7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoZGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIHdoYXQgdGhlIGhlbGwganVzdCBoYXBwZW5lZD8gdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX2hhbmRzaGFrZUxpc3RlbmVyKGRhdGEpIC0+IHVuZGVmaW5lZFxuICogLSBkYXRhKFN0cmluZyk6IFN0cmluZyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogU2VydmVyIGRhdGEgbGlzdGVuZXIgZm9yIHRoZSBoYW5kc2hha2UgLSB3YWl0cyBmb3IgdGhlIDIyMCByZXNwb25zZVxuICogZnJvbSB0aGUgc2VydmVyIChjb25uZWN0aW9uIGVzdGFibGlzaGVkKS5cbiAqKi9cblNNVFBDbGllbnQucHJvdG90eXBlLl9oYW5kc2hha2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICBjb25zb2xlLmxvZyhcIkNPTk5FQ1RJT04gKFwiK3RoaXMuaW5zdGFuY2VJZCtcIik6IFwiK2RhdGEudG9TdHJpbmcoXCJ1dGYtOFwiKS50cmltKCkpO1xuICAgIGlmKGRhdGEudG9TdHJpbmcoXCJ1dGYtOFwiKS50cmltKCkuc3Vic3RyKDAsMyk9PVwiMjIwXCIpe1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlOyAvLyBjb25uZWN0aW9uIGVzdGFibGlzaGVkXG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW9uIGVzdGFibGlzaGVkISAoXCIrdGhpcy5pbnN0YW5jZUlkK1wiKVwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2hhbmRzaGFrZShjYWxsYmFjayk7XG4gICAgfWVsc2V7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW9uIGZhaWxlZCEgKFwiK3RoaXMuaW5zdGFuY2VJZCtcIilcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggXCIrZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAqIHNtdHAuU01UUENsaWVudCNfc3RhcnR0bHNIYW5kbGVyKGNhbGxiYWNrKSAtPiB1bmRlZmluZWRcbiAqIC0gY2FsbGJhY2sgKEZ1bmN0aW9uKTogRnVuY3Rpb24gdG8gYmUgcnVuIGFmdGVyIGNvbm5lY3Rpb25cbiAqIFxuICogSW5pdGlhdGVzIGEgVExTIHNlc3Npb24gd2l0aCB0aGUgc2VydmVyXG4gKiovXG5TTVRQQ2xpZW50LnByb3RvdHlwZS5fc3RhcnR0bHNIYW5kbGVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuZGVidWcpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNUQVJUVExTOiAoXCIrdGhpcy5pbnN0YW5jZUlkK1wiKVwiKTtcbiAgICB9XG4gICAgdGhpcy5fc2VuZENvbW1hbmQoXCJTVEFSVFRMU1wiLCAoZnVuY3Rpb24oZXJyb3IsIGRhdGEpe1xuICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZ25vcmVfZGF0YSA9IHRydWU7XG4gICAgICAgIHZhciBzc2xfc29ja2V0O1xuICAgICAgICBzc2xfc29ja2V0ID0gc3RhcnR0bHModGhpcy5fY29ubmVjdGlvbiwgdGhpcy5vcHRpb25zLCAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5kZWJ1ZyAmJiAhc3NsX3NvY2tldC5hdXRob3JpemVkKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKWkuKWkuKWkiBXQVJOSU5HOiBUTFMgRVJST1IgKFwiK3NzbF9zb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yK1wiKSDilpLilpLilpJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNzbF9zb2NrZXQub24oXCJkYXRhXCIsdGhpcy5fb25EYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsdGhpcy5fb25EYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBzc2xfc29ja2V0O1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVfZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZGF0YV9yZW1haW5kZXIgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9zdGFibGVcIik7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX2hhbmRzaGFrZShjYWxsYmFjaykgLT4gdW5kZWZpbmVkXG4gKiAtIGNhbGxiYWNrIChGdW5jdGlvbik6IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGxvZ2luIGFmdGVyIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICogXG4gKiBXaWxsIGJlIHJ1biBhZnRlciBhIFRDUCBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgZXN0YWJsaXNoZWQuIE1ha2VzXG4gKiBhIEVITE8gY29tbWFuZCAoZmFsbGJhY2tzIHRvIEhFTE8gb24gZmFpbHVyZSkgYW5kIGZvcndhcmRzIHRoZSBjYWxsYmFjayB0b1xuICogbG9naW4gZnVuY3Rpb24gb24gc3VjY2Vzcy5cbiAqKi9cblNNVFBDbGllbnQucHJvdG90eXBlLl9oYW5kc2hha2UgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgXG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB0aGlzLl9zZW5kQ29tbWFuZChcIkVITE8gXCIrdGhpcy5ob3N0bmFtZSwgKGZ1bmN0aW9uKGVycm9yLCBkYXRhKXtcbiAgICAgICAgaWYoZXJyb3Ipe1xuXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBIRUxPXG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZChcIkhFTE8gXCIrdGhpcy5ob3N0bmFtZSwgKGZ1bmN0aW9uKGVycm9yLCBkYXRhKXtcbiAgICAgICAgICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3RlX2V4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9naW5IYW5kbGVyKGNhbGxiYWNrKTsgICAgXG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBjaGVjayBmb3IgcGlwZWxpbmluZyBzdXBwb3J0XG4gICAgICAgIGlmKGRhdGEubWF0Y2goL1BJUEVMSU5JTkcvaSkpe1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVfcGlwZWxpbmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGNoZWNrIGZvciBwaXBlbGluaW5nIHN1cHBvcnRcbiAgICAgICAgaWYoZGF0YS5tYXRjaCgvQVVUSCg/OlxccytbXlxcbl0qXFxzK3xcXHMrKVBMQUlOL2kpKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlX2F1dGhfcGxhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBwaXBlbGluaW5nIHN1cHBvcnRcbiAgICAgICAgaWYoZGF0YS5tYXRjaCgvQVVUSCg/OlxccytbXlxcbl0qXFxzK3xcXHMrKUxPR0lOL2kpKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlX2F1dGhfbG9naW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBjaGVjayBmb3IgVExTIHN1cHBvcnRcbiAgICAgICAgaWYoZGF0YS5tYXRjaCgvU1RBUlRUTFMvaSkpe1xuICAgICAgICAgICAgaWYoIXRoaXMucmVtb3RlX3N0YXJ0dGxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVfc3RhcnR0bHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRscyBhbmQgcmVydW4gSEVMT1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0dGxzSGFuZGxlcih0aGlzLl9oYW5kc2hha2UuYmluZCh0aGlzLGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9zdGFibGVcIik7XG4gICAgICAgIC8vIGNoZWNrIGxvZ2luIGFmdGVyIHN1Y2Nlc3NmdWwgaGFuZHNoYWtlXG4gICAgICAgIHRoaXMuX2xvZ2luSGFuZGxlcihjYWxsYmFjayk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG59XG5cbi8qKlxuICogc210cC5TTVRQQ2xpZW50I193YWl0Rm9yVGltZW91dCgpIC0+IGZ1bmN0aW9uXG4gKiBcbiAqIFdhaXRzIGZvciAxMCBzZWNvbmRzIGFmdGVyIGNvbm5lY3Rpb24gYW5kIGlmIG5vdGhpbmcgaGFwcGVuZWQgZW1pdHMgYW4gZXJyb3JcbiAqKi9cblNNVFBDbGllbnQucHJvdG90eXBlLl93YWl0Rm9yVGltZW91dCA9IGZ1bmN0aW9uKHRpbWUpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0VGltZXIpO1xuICAgIHRoaXMuX3RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcIlRpbWVvdXQgd2FpdGluZyBmb3IgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIikpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSkuYmluZCh0aGlzKSwgdGltZSB8fCAxMCoxMDAwKTtcbn1cblxuLyoqXG4gKiBzbXRwLlNNVFBDbGllbnQjX29uRGF0YShkYXRhKSAtPiBmdW5jdGlvblxuICogLSBjYWxsYmFjayAoRnVuY3Rpb24pOiBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSB1c2VkIHdpdGggY29ubmVjdGlvblxuICogLSBkYXRhIChCdWZmZXIpOiBiaW5hcnkgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogUmVjZWl2ZXMgYmluYXJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLCBjb252ZXJ0cyBpdCB0byBzdHJpbmcgYW5kIGZvcndhcmRzXG4gKiB0byBhIHJlZ2lzdGVyZWQgbGlzdGVuZXIuIENvbmNhdGVuYXRlcyBtdWx0aWxpbmUgbWVzc2FnZXMgZXRjLlxuICoqL1xuU01UUENsaWVudC5wcm90b3R5cGUuX29uRGF0YSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkYXRhKXtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0VGltZXIpO1xuXG4gICAgaWYoIXRoaXMuX2Nvbm5lY3RlZCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kc2hha2VMaXN0ZW5lcihkYXRhLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIFxuICAgIGlmKHRoaXMuZGVidWcpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUkVDRUlWRSAoXCIrdGhpcy5pbnN0YW5jZUlkK1wiKTpcXG7ilJTilIDilIBcIitKU09OLnN0cmluZ2lmeShkYXRhLnRvU3RyaW5nKFwidXRmLThcIikpLEpTT04uc3RyaW5naWZ5KHRoaXMuX2RhdGFfcmVtYWluZGVyKSk7XG4gICAgICAgIFxuICAgIGlmKHRoaXMuaWdub3JlX2RhdGEpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgLy9IYXZlIHRvIGRvIGEgY29uY2F0IHRvIHByZXZlbnQgdGhlIHNwbGl0IGlzc3VlIHdoZXJlIGEgZGF0YSBwYWNrZXQgc3BsaXRzIGEgbGluZVxuICAgIC8vSUU6IFwiMS1cXHJcXG4yIFwiIHdpdGggZGF0YSBwYWNrZXRzIFwiMVwiIFwiLVxcclxcbjIgXCIsIHVzaW5nIHRoZSBzcGxpdCBtZXRob2RcbiAgICAvLyBiZWNvbWVzIFtcIjFcIixcIi1cIixcIjIgXCJdXG4gICAgdGhpcy5fZGF0YV9yZW1haW5kZXIgPSAoZGF0YS50b1N0cmluZyhcInV0Zi04XCIpICsgdGhpcy5fZGF0YV9yZW1haW5kZXIpO1xuICAgIHZhciBtYXRjaCA9IC8oPzpeXFxkKy4qJFxccj9cXG4pKj8oPzpeXFxkK1tcXCBdLiooPzpcXHI/XFxufCQpKS9tLmV4ZWModGhpcy5fZGF0YV9yZW1haW5kZXIpO1xuICAgIGlmKG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2RhdGFfcmVtYWluZGVyID0gdGhpcy5fZGF0YV9yZW1haW5kZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fZGF0YUxpc3RlbmVyKG1hdGNoWzBdLnJlcGxhY2UoL15cXHMqJC9tZyxcIlwiKSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogc210cC5TTVRQQ2xpZW50I19jcmVhdGVDb25uZWN0aW9uKGNhbGxiYWNrKSAtPiBmdW5jdGlvblxuICogLSBjYWxsYmFjayAoRnVuY3Rpb24pOiBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uLFxuICogICBzbXRwIGhhbmRzaGFrZSBhbmQgbG9naW5cbiAqIFxuICogQ3JlYXRlcyBhIFRDUCBjb25uZWN0aW9uIHRvIHRoZSBTTVRQIHNlcnZlciBhbmQgc2V0cyB1cCBuZWVkZWQgbGlzdGVuZXJzLlxuICoqL1xuU01UUENsaWVudC5wcm90b3R5cGUuX2NyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zc2wpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IHRsc2xpYi5jb25uZWN0KHRoaXMucG9ydCwgdGhpcy5ob3N0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbmV0bGliLmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5wb3J0LCB0aGlzLmhvc3QpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJlbmRcIiwgKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICAgIFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJjbG9zZVwiLCAoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICAgIFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJ0aW1lb3V0XCIsIChmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG4gICAgXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChmdW5jdGlvbihlcnJvcil7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICAgIFxuICAgIC8vMzAgc2Vjb25kcyB0byBjb25uZWN0XG4gICAgdGhpcy5fd2FpdEZvclRpbWVvdXQoMzAgKiAxMDAwKTtcbiAgICAvLzEwIHNlY29uZHMgZm9yIGRhdGFcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiY29ubmVjdFwiLCB0aGlzLl93YWl0Rm9yVGltZW91dC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiZGF0YVwiLCB0aGlzLl9vbkRhdGEgPSB0aGlzLl9vbkRhdGEuYmluZCh0aGlzLCBjYWxsYmFjaykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/starttls.js":
/*!*************************************************!*\
  !*** ./node_modules/nodemailer/lib/starttls.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Target API:\n//\n//  var s = require('net').createStream(25, 'smtp.example.com');\n//  s.on('connect', function() {\n//   require('starttls')(s, options, function() {\n//      if (!s.authorized) {\n//        s.destroy();\n//        return;\n//      }\n//\n//      s.end(\"hello world\\n\");\n//    });\n//  });\n//\n//\n\nmodule.exports = function starttls(socket, options, cb) {\n\n    var sslcontext = (__webpack_require__(/*! crypto */ \"crypto\").createCredentials)(options),\n        pair = (__webpack_require__(/*! tls */ \"tls\").createSecurePair)(sslcontext, false),\n        cleartext = pipe(pair, socket);\n\n    pair.on('secure', function() {\n        var verifyError = (pair._ssl || pair.ssl).verifyError();\n\n        if (verifyError) {\n            cleartext.authorized = false;\n            cleartext.authorizationError = verifyError;\n        } else {\n            cleartext.authorized = true;\n        }\n\n        if (cb) cb();\n    });\n\n    cleartext._controlReleased = true;\n    return cleartext;\n};\n\nfunction forwardEvents(events,emitterSource,emitterDestination) {\n    var map = {}, name, handler;\n    for(var i = 0; i < events.length; i++) {\n        name = events[i];\n        handler = (function generateForwardEvent(){\n            return function forwardEvent(name) {\n                return emitterDestination.emit.apply(emitterDestination, arguments);\n            }\n        })(name);\n        map[name] = handler;\n        emitterSource.on(name, handler);\n    }\n    return map;\n}\n\nfunction removeEvents(map,emitterSource) {\n    for(var k in map) {\n        emitterSource.removeListener(k,map[k])\n    }\n}\n\nfunction pipe(pair, socket) {\n    pair.encrypted.pipe(socket);\n    socket.pipe(pair.encrypted);\n\n    pair.fd = socket.fd;\n    \n    var cleartext = pair.cleartext;\n  \n    cleartext.socket = socket;\n    cleartext.encrypted = pair.encrypted;\n    cleartext.authorized = false;\n\n    function onerror(e) {\n        if (cleartext._controlReleased) {\n            cleartext.emit('error', e);\n        }\n    }\n\n    var map = forwardEvents([\"timeout\",\"end\",\"close\"], socket, cleartext);\n  \n    function onclose() {\n        socket.removeListener('error', onerror);\n        socket.removeListener('close', onclose);\n        removeEvents(map,socket)\n    }\n\n    socket.on('error', onerror);\n    socket.on('close', onclose);\n\n    return cleartext;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc3RhcnR0bHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsK0RBQW1DO0FBQ3hELGVBQWUsd0RBQStCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYWlhdXJjb2RlLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3N0YXJ0dGxzLmpzP2ExYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGFyZ2V0IEFQSTpcbi8vXG4vLyAgdmFyIHMgPSByZXF1aXJlKCduZXQnKS5jcmVhdGVTdHJlYW0oMjUsICdzbXRwLmV4YW1wbGUuY29tJyk7XG4vLyAgcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuLy8gICByZXF1aXJlKCdzdGFydHRscycpKHMsIG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuLy8gICAgICBpZiAoIXMuYXV0aG9yaXplZCkge1xuLy8gICAgICAgIHMuZGVzdHJveSgpO1xuLy8gICAgICAgIHJldHVybjtcbi8vICAgICAgfVxuLy9cbi8vICAgICAgcy5lbmQoXCJoZWxsbyB3b3JsZFxcblwiKTtcbi8vICAgIH0pO1xuLy8gIH0pO1xuLy9cbi8vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RhcnR0bHMoc29ja2V0LCBvcHRpb25zLCBjYikge1xuXG4gICAgdmFyIHNzbGNvbnRleHQgPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVDcmVkZW50aWFscyhvcHRpb25zKSxcbiAgICAgICAgcGFpciA9IHJlcXVpcmUoJ3RscycpLmNyZWF0ZVNlY3VyZVBhaXIoc3NsY29udGV4dCwgZmFsc2UpLFxuICAgICAgICBjbGVhcnRleHQgPSBwaXBlKHBhaXIsIHNvY2tldCk7XG5cbiAgICBwYWlyLm9uKCdzZWN1cmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZlcmlmeUVycm9yID0gKHBhaXIuX3NzbCB8fMKgcGFpci5zc2wpLnZlcmlmeUVycm9yKCk7XG5cbiAgICAgICAgaWYgKHZlcmlmeUVycm9yKSB7XG4gICAgICAgICAgICBjbGVhcnRleHQuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJ0ZXh0LmF1dGhvcml6YXRpb25FcnJvciA9IHZlcmlmeUVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJ0ZXh0LmF1dGhvcml6ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNiKSBjYigpO1xuICAgIH0pO1xuXG4gICAgY2xlYXJ0ZXh0Ll9jb250cm9sUmVsZWFzZWQgPSB0cnVlO1xuICAgIHJldHVybiBjbGVhcnRleHQ7XG59O1xuXG5mdW5jdGlvbiBmb3J3YXJkRXZlbnRzKGV2ZW50cyxlbWl0dGVyU291cmNlLGVtaXR0ZXJEZXN0aW5hdGlvbikge1xuICAgIHZhciBtYXAgPSB7fSwgbmFtZSwgaGFuZGxlcjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBldmVudHNbaV07XG4gICAgICAgIGhhbmRsZXIgPSAoZnVuY3Rpb24gZ2VuZXJhdGVGb3J3YXJkRXZlbnQoKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBmb3J3YXJkRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVyRGVzdGluYXRpb24uZW1pdC5hcHBseShlbWl0dGVyRGVzdGluYXRpb24sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKG5hbWUpO1xuICAgICAgICBtYXBbbmFtZV0gPSBoYW5kbGVyO1xuICAgICAgICBlbWl0dGVyU291cmNlLm9uKG5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudHMobWFwLGVtaXR0ZXJTb3VyY2UpIHtcbiAgICBmb3IodmFyIGsgaW4gbWFwKSB7XG4gICAgICAgIGVtaXR0ZXJTb3VyY2UucmVtb3ZlTGlzdGVuZXIoayxtYXBba10pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBwaXBlKHBhaXIsIHNvY2tldCkge1xuICAgIHBhaXIuZW5jcnlwdGVkLnBpcGUoc29ja2V0KTtcbiAgICBzb2NrZXQucGlwZShwYWlyLmVuY3J5cHRlZCk7XG5cbiAgICBwYWlyLmZkID0gc29ja2V0LmZkO1xuICAgIFxuICAgIHZhciBjbGVhcnRleHQgPSBwYWlyLmNsZWFydGV4dDtcbiAgXG4gICAgY2xlYXJ0ZXh0LnNvY2tldCA9IHNvY2tldDtcbiAgICBjbGVhcnRleHQuZW5jcnlwdGVkID0gcGFpci5lbmNyeXB0ZWQ7XG4gICAgY2xlYXJ0ZXh0LmF1dGhvcml6ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG9uZXJyb3IoZSkge1xuICAgICAgICBpZiAoY2xlYXJ0ZXh0Ll9jb250cm9sUmVsZWFzZWQpIHtcbiAgICAgICAgICAgIGNsZWFydGV4dC5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IGZvcndhcmRFdmVudHMoW1widGltZW91dFwiLFwiZW5kXCIsXCJjbG9zZVwiXSwgc29ja2V0LCBjbGVhcnRleHQpO1xuICBcbiAgICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRzKG1hcCxzb2NrZXQpXG4gICAgfVxuXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHNvY2tldC5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHJldHVybiBjbGVhcnRleHQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/starttls.js\n");

/***/ })

};
;